# ç¬¬10ç« ï¼šRAG ä¸ Agent çš„ååŒç¼–æ’å®è·µ

# å‰è¨€
å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯é²«å°é±¼ã€‚æ˜¯ä¸€å`ä¸å†™å‰ç«¯ä»£ç `çš„å‰ç«¯å·¥ç¨‹å¸ˆï¼Œçƒ­è¡·äºåˆ†äº«éå‰ç«¯çš„çŸ¥è¯†ï¼Œå¸¦é¢†åˆ‡å›¾ä»”é€ƒç¦»åˆ‡å›¾åœˆå­ï¼Œæ¬¢è¿å…³æ³¨æˆ‘ï¼Œå¾®ä¿¡å…¬ä¼—å·ï¼š`ã€Šé²«å°é±¼ä¸æ­£ç»ã€‹`ã€‚æ¬¢è¿ç‚¹èµã€æ”¶è—ã€å…³æ³¨ï¼Œä¸€é”®ä¸‰è¿ï¼ï¼

## ğŸ¯ æœ¬ç« å­¦ä¹ ç›®æ ‡
- ç»Ÿä¸€ RAG ä¸ Agent çš„åä½œèŒƒå¼ï¼šå·¥å…·åŒ–æ£€ç´¢ã€ç»“æ„åŒ–å›ç­”ã€å¯è¿½æº¯ä¸å¯æ§
- æ„å»ºâ€œä¼šè®¡åˆ’ã€ä¼šæ£€ç´¢ã€ä¼šè°ƒç”¨å¤–éƒ¨ APIã€ä¼šè‡ªæˆ‘ä¿®å¤â€çš„æ··åˆå‹ Agent
- ä½¿ç”¨ LangGraph ç¼–æ’ RAG å·¥å…·ã€è®¡åˆ’åˆ†è§£ã€å›é€€/é‡è¯•ã€äººå·¥ç¡®è®¤ç­‰å¤æ‚æµç¨‹
- åœ¨ Next.js ä¸­å®ç°ç«¯åˆ°ç«¯ APIï¼ˆSSEï¼‰å’Œå‰ç«¯å¯è§†åŒ–ï¼ˆæ­¥éª¤æ—¶é—´çº¿ + å¼•ç”¨ï¼‰
- å®æˆ˜é¡¹ç›®ï¼šä¼ä¸šçŸ¥è¯†é—®ç­” + å·¥å•è‡ªåŠ¨åŒ– + æ•°æ®å¯¹é½æ ¡éªŒï¼ˆåŒæ¨¡æ€/å¤šæ¥æºï¼‰
- å·¥ç¨‹åŒ–ï¼šç¼“å­˜ã€é™çº§ã€å®¡è®¡ã€å®‰å…¨ä¸éšç§éš”ç¦»ã€åŸºçº¿è¯„ä¼°ä¸ A/B

---

## ğŸ§© ååŒèŒƒå¼ï¼šRAG ä½œä¸º Agent çš„ä¸€ç­‰å…¬æ°‘å·¥å…·

### 10.1 ä¸ºä»€ä¹ˆè¦å°† RAG å˜æˆâ€œå·¥å…·â€
- Agent çš„æ ¸å¿ƒæ˜¯â€œæ ¹æ®ç›®æ ‡ä¸ä¸Šä¸‹æ–‡é€‰æ‹©åˆé€‚çš„å·¥å…·æ‰§è¡Œâ€ï¼ŒRAG å¯è¢«æŠ½è±¡ä¸ºä¸€ç§é«˜è´¨é‡çš„â€œçŸ¥è¯†æ£€ç´¢å·¥å…·â€
- å°†â€œæ£€ç´¢â†’èåˆâ†’ç”Ÿæˆâ†’å¼•ç”¨æ ¡éªŒâ€å°è£…ä¸ºä¸€ä¸ªå—æ§çš„å¯è§‚æµ‹å·¥å…·ï¼ŒAgent åªéœ€è¦ä¼ å‚ä¸æ¶ˆè´¹ç»“æœ
- ä¼˜ç‚¹ï¼šå¯æ§æ€§å¼ºã€å¯æ›¿æ¢ï¼ˆä¸åŒæ£€ç´¢ç­–ç•¥/å‘é‡åº“ï¼‰ã€å¯è¯„æµ‹ï¼ˆRecall/Citationï¼‰ã€æ˜“é›†æˆï¼ˆå’Œå…¶å®ƒå·¥å…·å¹¶åˆ—ï¼‰

### 10.2 æŠ½è±¡æ¥å£è®¾è®¡
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/rag-tool.ts
import { Tool } from "@langchain/core/tools";
import { z } from "zod";
import { buildRagPipeline } from "@/src/ch07/rag-pipeline";

export class RAGTool extends Tool {
  name = "rag_query";
  description = "åŸºäºä¼ä¸šçŸ¥è¯†åº“çš„æ£€ç´¢å¢å¼ºé—®ç­”ï¼Œè¿”å›å¸¦å¼•ç”¨ä¸ç½®ä¿¡åº¦çš„ç»“æ„åŒ–ç»“æœ";
  schema = z.object({
    question: z.string().describe("ç”¨æˆ·é—®é¢˜"),
    domain: z.string().default("news").describe("ä¸šåŠ¡åŸŸï¼Œå¦‚ news/policy")
  });

  async _call(input: { question: string; domain?: string }) {
    const pipeline = await buildRagPipeline(input.domain || "news");
    const out = await pipeline.invoke(input.question);
    return JSON.stringify(out);
  }
}
```

---

## ğŸ¤– è®¡åˆ’é©±åŠ¨çš„æ··åˆå‹ Agentï¼ˆPlan â†’ Act â†’ Observe â†’ Reflectï¼‰

### 10.3 Agent èƒ½åŠ›çŸ©é˜µ
- RAG æ£€ç´¢ï¼ˆçŸ¥è¯†ï¼‰
- Calculatorï¼ˆæ•°å€¼è®¡ç®—ï¼‰
- Web/APIï¼ˆå¤–éƒ¨æ•°æ®ï¼‰
- Timeï¼ˆæ—¶é—´/æ—¶åŒºï¼‰
- Ticketï¼ˆå·¥å•/ä»»åŠ¡ç®¡ç†ï¼‰
- Reflectï¼ˆè‡ªæˆ‘åæ€ä¸ä¿®æ­£ï¼‰

### 10.4 å·¥å…·æ³¨å†Œä¸­å¿ƒ
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/tools.ts
import { Tool } from "@langchain/core/tools";
import { SearchTool, CalculatorTool, TimeTool } from "@/src/ch08/tools";
import { RAGTool } from "./rag-tool";

export class ToolRegistry {
  private map = new Map<string, Tool>();
  constructor() {
    [new SearchTool(), new CalculatorTool(), new TimeTool(), new RAGTool()].forEach(t => this.map.set(t.name, t));
  }
  all() { return [...this.map.values()]; }
  get(name: string) { return this.map.get(name); }
}
```

### 10.5 è®¡åˆ’åˆ†è§£ Agentï¼ˆReAct+Planï¼‰
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/plan-agent.ts
import { ChatOpenAI } from "@langchain/openai";
import { PromptTemplate } from "@langchain/core/prompts";
import { ToolRegistry } from "./tools";

export type PlanStep = { id: number; tool: string; args: any; goal: string };
export type Plan = { steps: PlanStep[]; rationale: string };

const planPrompt = PromptTemplate.fromTemplate(`
ä½ æ˜¯ä»»åŠ¡è§„åˆ’å™¨ã€‚è¯·å°†ç”¨æˆ·ç›®æ ‡åˆ†è§£ä¸ºè‹¥å¹²å¯æ‰§è¡Œçš„æ­¥éª¤ã€‚
- ä»…ä½¿ç”¨æä¾›çš„å·¥å…·ã€‚
- å·¥å…·å‚æ•°å¿…é¡»æ˜¯ JSONã€‚
- è‹¥éœ€è¦ä¼ä¸šçŸ¥è¯†è¯·ä½¿ç”¨ rag_queryã€‚

å¯ç”¨å·¥å…·ï¼š\n{tools}

ç”¨æˆ·ç›®æ ‡ï¼š{goal}

è¾“å‡º JSONï¼š
{
  "rationale": string,
  "steps": [
    {"id": 1, "tool": string, "args": object, "goal": string},
    ...
  ]
}
`);

export class PlanAgent {
  private llm = new ChatOpenAI({ temperature: 0 });
  private registry = new ToolRegistry();

  async makePlan(goal: string): Promise<Plan> {
    const toolsDesc = this.registry.all().map(t => `${t.name}: ${t.description}`).join("\n");
    const res = await planPrompt.pipe(this.llm).invoke({ tools: toolsDesc, goal });
    const json = JSON.parse(String(res.content));
    return json as Plan;
  }
}
```

### 10.6 æ‰§è¡Œå™¨ï¼šå¸¦è§‚å¯Ÿä¸å›å†™
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/executor.ts
import { ToolRegistry } from "./tools";

export type ExecutionLog = {
  stepId: number;
  tool: string;
  args: any;
  observation: string;
  success: boolean;
  startedAt: number;
  endedAt: number;
  error?: string;
};

export class Executor {
  private registry = new ToolRegistry();

  async run(plan: { steps: any[] }): Promise<{ logs: ExecutionLog[] }> {
    const logs: ExecutionLog[] = [];
    for (const s of plan.steps) {
      const startedAt = Date.now();
      try {
        const tool = this.registry.get(s.tool);
        if (!tool) throw new Error(`å·¥å…·ä¸å­˜åœ¨ï¼š${s.tool}`);
        const observation = await tool._call(s.args);
        logs.push({ stepId: s.id, tool: s.tool, args: s.args, observation, success: true, startedAt, endedAt: Date.now() });
      } catch (e: any) {
        logs.push({ stepId: s.id, tool: s.tool, args: s.args, observation: "", success: false, startedAt, endedAt: Date.now(), error: e.message });
        break;
      }
    }
    return { logs };
  }
}
```

### 10.7 åæ€ä¸ä¿®æ­£ï¼ˆReflectï¼‰
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/reflect.ts
import { ChatOpenAI } from "@langchain/openai";
import { PromptTemplate } from "@langchain/core/prompts";

const reflectPrompt = PromptTemplate.fromTemplate(`
ä½ æ˜¯æ‰§è¡Œå®¡è®¡å™¨ã€‚ç»™å®šè®¡åˆ’ä¸æ‰§è¡Œæ—¥å¿—ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦ä¿®æ­£ï¼š
- å¦‚æœ rag_query ç¼ºå°‘å¼•ç”¨æˆ–ç½®ä¿¡åº¦è¿‡ä½ï¼Œå»ºè®®å¢å¤§ TopK æˆ–æ”¹å†™æŸ¥è¯¢
- å¦‚æœå¤–éƒ¨ API å¤±è´¥ï¼Œå»ºè®®é‡è¯•æˆ–é™çº§

è¾“å…¥ï¼š
è®¡åˆ’ï¼š{plan}
æ—¥å¿—ï¼š{logs}
è¾“å‡º JSONï¼š
{"need_fix": boolean, "new_plan": object | null, "notes": string}
`);

export async function reflect(plan: any, logs: any) {
  const llm = new ChatOpenAI({ temperature: 0 });
  const res = await reflectPrompt.pipe(llm).invoke({ plan: JSON.stringify(plan), logs: JSON.stringify(logs) });
  return JSON.parse(String(res.content));
}
```

---

## ğŸŒ³ ç”¨ LangGraph ç¼–æ’æ··åˆæµç¨‹ï¼ˆPlan â†’ Execute â†’ Reflect â†’ Loopï¼‰

### 10.8 çŠ¶æ€å®šä¹‰
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/state.ts
export type MixState = {
  goal: string;
  plan?: any;
  exec?: { logs: any[] };
  reflect?: { need_fix: boolean; new_plan?: any; notes?: string };
  result?: any;
  error?: string;
  timeline: any[];
};
```

### 10.9 èŠ‚ç‚¹å®ç°
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/nodes.ts
import { PlanAgent } from "./plan-agent";
import { Executor } from "./executor";
import { reflect } from "./reflect";
import { MixState } from "./state";

export async function planNode(s: MixState): Promise<Partial<MixState>> {
  const agent = new PlanAgent();
  const plan = await agent.makePlan(s.goal);
  return { plan, timeline: [{ type: "plan", at: Date.now(), data: plan }] };
}

export async function executeNode(s: MixState): Promise<Partial<MixState>> {
  const ex = new Executor();
  const exec = await ex.run(s.plan);
  return { exec, timeline: [{ type: "exec", at: Date.now(), data: exec }] };
}

export async function reflectNode(s: MixState): Promise<Partial<MixState>> {
  const rf = await reflect(s.plan, s.exec);
  return { reflect: rf, timeline: [{ type: "reflect", at: Date.now(), data: rf }] };
}

export async function finalizeNode(s: MixState): Promise<Partial<MixState>> {
  // ä»æ‰§è¡Œæ—¥å¿—ä¸­æŠ½å–æœ€ç»ˆç»“æœï¼ˆä¾‹å¦‚ rag_query çš„å›ç­”ï¼‰
  const last = [...(s.exec?.logs || [])].reverse().find(l => l.tool === "rag_query" && l.success);
  const result = last ? JSON.parse(last.observation) : { answer: "æœªå¾—åˆ°æœ‰æ•ˆç»“æœ" };
  return { result, timeline: [{ type: "final", at: Date.now(), data: result }] };
}
```

### 10.10 å›¾ä¸å¾ªç¯ç¼–æ’
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/graph.ts
import { StateGraph } from "@langchain/langgraph";
import { MixState } from "./state";
import { planNode, executeNode, reflectNode, finalizeNode } from "./nodes";

export async function buildMixGraph() {
  const g = new StateGraph<MixState>({
    channels: {
      goal: { value: "" },
      plan: { value: {} },
      exec: { value: { logs: [] } },
      reflect: { value: { need_fix: false } },
      result: { value: {} },
      error: { value: "" },
      timeline: { value: [], merge: (a,b)=>[...a,...b] },
    }
  });

  g.addNode("plan", planNode);
  g.addNode("execute", executeNode);
  g.addNode("reflect", reflectNode);
  g.addNode("final", finalizeNode);

  g.addEdge("start", "plan");
  g.addEdge("plan", "execute");
  g.addEdge("execute", "reflect");

  // è‹¥éœ€è¦ä¿®æ­£åˆ™å›åˆ° planï¼Œå¦åˆ™è¿›å…¥æœ€ç»ˆ
  g.addConditionalEdges("reflect", (s) => (s.reflect?.need_fix ? "replan" : "final"), {
    replan: "plan",
    final: "final",
  });

  g.addEdge("final", "end");

  return g.compile();
}
```

---

## ğŸŒ Next.jsï¼šSSE å®æ—¶æ—¶é—´çº¿ + å¼•ç”¨å±•ç¤º

### 10.11 APIï¼š/api/mixï¼ˆSSEï¼‰
```typescript
// æ–‡ä»¶ï¼šsrc/app/api/mix/route.ts
import { NextRequest } from "next/server";
import { buildMixGraph } from "@/src/ch10/graph";

export const runtime = "edge";

export async function POST(req: NextRequest) {
  const { goal } = await req.json();
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      try {
        const app = await buildMixGraph();
        controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: "start" })}\n\n`));
        const out = await app.invoke({ goal, timeline: [] });
        for (const e of out.timeline) {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: "event", data: e })}\n\n`));
        }
        controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: "result", data: out.result })}\n\n`));
      } catch (e: any) {
        controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: "error", message: e.message })}\n\n`));
      } finally { controller.close(); }
    }
  });
  return new Response(stream, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache" } });
}
```

### 10.12 å‰ç«¯é¡µé¢ï¼šæ­¥éª¤æ—¶é—´çº¿ + å¼•ç”¨å¡ç‰‡
```tsx
// æ–‡ä»¶ï¼šsrc/app/mix/page.tsx
"use client";
import { useEffect, useRef, useState } from "react";

type EventItem = { type: string; at?: number; data: any };

export default function MixPage() {
  const [events, setEvents] = useState<EventItem[]>([]);
  const [result, setResult] = useState<any>(null);
  const [goal, setGoal] = useState("");
  const esRef = useRef<EventSource | null>(null);

  const run = async () => {
    setEvents([]); setResult(null);
    const res = await fetch("/api/mix", { method: "POST", body: JSON.stringify({ goal }) });
    // ç®€åŒ–ï¼šæ¼”ç¤ºä½¿ç”¨åŒä¸€è·¯ç”±äº‹ä»¶æµ
    const es = new EventSource("/api/mix");
    esRef.current = es;
    es.onmessage = (e) => {
      const msg = JSON.parse(e.data);
      if (msg.type === "event") setEvents(prev => [...prev, msg.data]);
      if (msg.type === "result") setResult(msg.data);
    };
  };

  return (
    <main className="max-w-4xl mx-auto p-4 space-y-4">
      <h1 className="text-2xl font-bold">RAG Ã— Agent ååŒç¼–æ’</h1>
      <div className="flex gap-2">
        <input className="flex-1 border rounded px-3 py-2" value={goal} onChange={e=>setGoal(e.target.value)} placeholder="ä¾‹å¦‚ï¼šç»™æˆ‘ä¸€ä»½æœ¬å‘¨è¡Œä¸šæ–°é—»æ‘˜è¦å¹¶é™„å¼•ç”¨" />
        <button onClick={run} className="px-4 py-2 bg-blue-600 text-white rounded">è¿è¡Œ</button>
      </div>

      <section className="space-y-2">
        <h2 className="font-semibold">æ‰§è¡Œæ—¶é—´çº¿</h2>
        <ol className="space-y-2">
          {events.map((e, idx) => (
            <li key={idx} className="border rounded p-3 bg-gray-50">
              <div className="text-sm opacity-70">{new Date(e.at || Date.now()).toLocaleString()}</div>
              <div className="font-medium">{e.type}</div>
              <pre className="whitespace-pre-wrap break-words text-xs">{JSON.stringify(e.data, null, 2)}</pre>
            </li>
          ))}
        </ol>
      </section>

      {result && (
        <section className="space-y-2">
          <h2 className="font-semibold">æœ€ç»ˆç»“æœ</h2>
          <pre className="whitespace-pre-wrap break-words text-sm bg-gray-50 p-3 rounded">{JSON.stringify(result, null, 2)}</pre>
          {Array.isArray(result.citations) && (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {result.citations.map((c: any, i: number) => (
                <div key={i} className="border rounded p-3">
                  <div className="text-sm">æ¥æºï¼š{c.source}</div>
                  <div className="text-xs opacity-70">ç‰‡æ®µï¼š{c.chunkId}</div>
                </div>
              ))}
            </div>
          )}
        </section>
      )}
    </main>
  );
}
```

---

## ğŸš€ å®æˆ˜ï¼šä¼ä¸šçŸ¥è¯†é—®ç­” + å·¥å•è‡ªåŠ¨åŒ– + å¤šæ¥æºå¯¹é½æ ¡éªŒ

### 10.13 éœ€æ±‚
- ç”¨æˆ·å‘é—® â†’ è§„åˆ’ â†’ RAG å›ç­” â†’ è‹¥ç½®ä¿¡åº¦ä½è§¦å‘â€œå¤‡ç”¨æ¥æºï¼ˆå¤–éƒ¨ API/æœç´¢ï¼‰â€
- å¼•ç”¨å¿…éœ€ï¼›å¤šæ¥æºä¸€è‡´æ€§æ ¡éªŒï¼ˆè‹¥å†²çªï¼Œè§¦å‘äººå·¥ç¡®è®¤æˆ–åŠ æƒæŠ•ç¥¨ï¼‰
- å¯¹äºå¤æ‚é—®é¢˜è‡ªåŠ¨åˆ›å»ºå·¥å•ï¼Œå¹¶é™„ä¸Šå¼•ç”¨ä¸æ£€ç´¢ç‰‡æ®µä½œä¸ºè¯æ®

### 10.14 ä¸€è‡´æ€§æ ¡éªŒå™¨ï¼ˆç¤ºæ„ï¼‰
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/consistency.ts
import { ChatOpenAI } from "@langchain/openai";
import { PromptTemplate } from "@langchain/core/prompts";

const prompt = PromptTemplate.fromTemplate(`
ç»™å®šå¤šä¸ªæ¥æºçš„ç­”æ¡ˆä¸å¼•ç”¨ï¼Œåˆ¤æ–­æ˜¯å¦ä¸€è‡´ï¼Œè¾“å‡º JSONï¼š
{"consistent": boolean, "reason": string, "decision": "trust_internal|trust_external|need_human"}

å†…éƒ¨ç­”æ¡ˆï¼š{internal}
å¤–éƒ¨ç­”æ¡ˆï¼š{external}
å¼•ç”¨ï¼š{cites}
`);

export async function checkConsistency(internal: any, external: any) {
  const llm = new ChatOpenAI({ temperature: 0 });
  const res = await prompt.pipe(llm).invoke({ internal: JSON.stringify(internal), external: JSON.stringify(external), cites: JSON.stringify([internal.citations, external.citations]) });
  return JSON.parse(String(res.content));
}
```

### 10.15 å·¥å•åˆ›å»ºå·¥å…·ï¼ˆç¤ºæ„ï¼‰
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/ticket.ts
import { Tool } from "@langchain/core/tools";
import { z } from "zod";

export class TicketTool extends Tool {
  name = "create_ticket";
  description = "åˆ›å»ºå·¥å•ï¼Œå‚æ•°åŒ…å«æ ‡é¢˜/æè¿°/å¼•ç”¨/ä¼˜å…ˆçº§";
  schema = z.object({
    title: z.string(),
    description: z.string(),
    citations: z.array(z.object({ source: z.string(), chunkId: z.string() })).default([]),
    priority: z.enum(["low","medium","high"]).default("medium")
  });
  async _call(input: any) {
    const id = `T-${Date.now()}`;
    return `å·¥å•å·²åˆ›å»ºï¼š${id}`;
  }
}
```

### 10.16 ç»„åˆ Planï¼šä¼˜å…ˆç”¨ RAGï¼Œç½®ä¿¡åº¦ä½å†æœç´¢ï¼Œå†²çªåˆ™å®¡æ‰¹
```typescript
// æ–‡ä»¶ï¼šsrc/ch10/policy-plan.ts
export const policyPlan = {
  rationale: "å…ˆç”¨ä¼ä¸šçŸ¥è¯†åº“ï¼›è‹¥ä½äº0.6ï¼Œå†è¿›è¡Œå¤–éƒ¨æœç´¢ï¼›ä¸ä¸€è‡´åˆ™äººå·¥å®¡æ‰¹",
  steps: [
    { id: 1, tool: "rag_query", args: { question: "{goal}" }, goal: "ä¼ä¸šçŸ¥è¯†å›ç­”" },
    { id: 2, tool: "search", args: { query: "{goal}" }, goal: "å¤–éƒ¨ä¿¡æ¯å¯¹é½" },
  ]
};
```

---

## âš™ï¸ å·¥ç¨‹åŒ–ï¼šç¼“å­˜ã€é™çº§ã€å®¡è®¡ã€å®‰å…¨

### 10.17 ç¼“å­˜ç­–ç•¥
- è®¡åˆ’ç¼“å­˜ï¼š`hash(goal)` ä½œä¸º keyï¼ŒçŸ­æœŸå¤ç”¨
- RAG ç»“æœç¼“å­˜ï¼šå¯¹çƒ­é—¨é—®é¢˜è®¾ç½®çŸ­æœŸç¼“å­˜ï¼Œå«å¼•ç”¨ä¸ç½®ä¿¡åº¦
- å·¥å…·çº§ç¼“å­˜ä¸æ‰¹å¤„ç†ï¼ˆå‚è§ç¬¬5ç« ï¼‰

### 10.18 é™çº§ä¸å›é€€
- RAG å¤±è´¥ â†’ å›é€€åˆ° keyword + rerank
- å¤–éƒ¨ API è¶…æ—¶ â†’ è¿”å›å†…éƒ¨ç­”æ¡ˆå¹¶æç¤ºâ€œå¤–éƒ¨æ•°æ®æš‚ä¸å¯ç”¨â€
- å›¾çº§åˆ«ï¼šè¶…å‡ºæœ€å¤§å¾ªç¯æ¬¡æ•°ç›´æ¥äº§å‡ºâ€œå½“å‰ä¸å¯å›ç­”â€çš„ç»“æ„åŒ–å¡ç‰‡

### 10.19 å®¡è®¡ä¸å®‰å…¨
- å…¨é“¾è·¯å®¡è®¡ï¼šè®¡åˆ’ã€å·¥å…·è°ƒç”¨ã€ç»“æœã€å¼•ç”¨ã€äººå·¥ä»‹å…¥
- æŒ‰ç§Ÿæˆ·/éƒ¨é—¨éš”ç¦»çŸ¥è¯†åº“ä¸æƒé™
- æç¤ºæ³¨å…¥é˜²æŠ¤ï¼šç³»ç»Ÿæç¤ºå›ºå®šï¼Œå·¥å…·å‚æ•°ç™½åå•ä¸æ­£åˆ™æ ¡éªŒ

### 10.20 è¯„ä¼°ä¸ A/B
- åŸºçº¿ï¼šæ— å¤–éƒ¨æœç´¢ vs æ··åˆæœç´¢ï¼›ä¸åŒ TopK/MMRï¼›ä¸åŒåæ€ç­–ç•¥
- æŒ‡æ ‡ï¼šæ»¡æ„åº¦ã€Citation Accuracyã€å¹³å‡å»¶è¿Ÿã€æˆæœ¬ã€äººå·¥æ¥ç®¡ç‡

---

## ğŸ“š å»¶ä¼¸é“¾æ¥
- LangChain Toolsï¼š`https://js.langchain.com/docs/modules/tools/`
- LangGraph çŠ¶æ€å›¾ï¼š`https://langchain-ai.github.io/langgraph/`
- ReAct + RAG å®è·µï¼š`https://js.langchain.com/docs/use_cases/question_answering/`

---

## âœ… æœ¬ç« å°ç»“
- å°† RAG å·¥å…·åŒ–ï¼Œä½¿å…¶æˆä¸º Agent çš„ä¸€ç­‰å…¬æ°‘ï¼Œæå‡å¯æ§ä¸å¯è§‚æµ‹
- æ„å»ºäº† Planâ†’Executeâ†’Reflect å¾ªç¯ï¼Œæ”¯æŒä¿®æ­£ã€é™çº§ä¸äººå·¥å®¡æ‰¹
- ç”¨ LangGraph ç¼–æ’å¤æ‚ååŒæµç¨‹ï¼Œå¹¶æä¾› Next.js ç«¯åˆ°ç«¯å®ç°
- ç»™å‡ºäº†ä¼ä¸šçŸ¥è¯† + å·¥å•è‡ªåŠ¨åŒ– + ä¸€è‡´æ€§æ ¡éªŒçš„å®æˆ˜è·¯çº¿

## ğŸ¯ ä¸‹ç« é¢„å‘Š
ä¸‹ä¸€ç« ã€Šè¯„æµ‹ä¸è§‚æµ‹ï¼šè®© AI åº”ç”¨å¯åº¦é‡å¯ä¼˜åŒ–ã€‹ä¸­ï¼Œæˆ‘ä»¬å°†ï¼š
- æ„å»ºè¯„æµ‹é›†ä¸ Golden Set
- æŒ‡æ ‡ä½“ç³»ï¼šRecall/MRR/Citation/æ»¡æ„åº¦/æˆæœ¬/å»¶è¿Ÿ
- LangSmith é›†æˆä¸ A/B å®éªŒå¹³å°æ­å»º

> æœ€åæ„Ÿè°¢é˜…è¯»ï¼æ¬¢è¿å…³æ³¨æˆ‘ï¼Œå¾®ä¿¡å…¬ä¼—å·ï¼š`ã€Šé²«å°é±¼ä¸æ­£ç»ã€‹`ã€‚æ¬¢è¿ç‚¹èµã€æ”¶è—ã€å…³æ³¨ï¼Œä¸€é”®ä¸‰è¿ï¼ï¼ï¼

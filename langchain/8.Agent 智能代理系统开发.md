# ç¬¬8ç« ï¼šAgent æ™ºèƒ½ä»£ç†ç³»ç»Ÿå¼€å‘

# å‰è¨€
å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯é²«å°é±¼ã€‚æ˜¯ä¸€å`ä¸å†™å‰ç«¯ä»£ç `çš„å‰ç«¯å·¥ç¨‹å¸ˆï¼Œçƒ­è¡·äºåˆ†äº«éå‰ç«¯çš„çŸ¥è¯†ï¼Œå¸¦é¢†åˆ‡å›¾ä»”é€ƒç¦»åˆ‡å›¾åœˆå­ï¼Œæ¬¢è¿å…³æ³¨æˆ‘ï¼Œå¾®ä¿¡å…¬ä¼—å·ï¼š`ã€Šé²«å°é±¼ä¸æ­£ç»ã€‹`ã€‚æ¬¢è¿ç‚¹èµã€æ”¶è—ã€å…³æ³¨ï¼Œä¸€é”®ä¸‰è¿ï¼ï¼

## ğŸ¯ æœ¬ç« å­¦ä¹ ç›®æ ‡
- æŒæ¡ Agent æ ¸å¿ƒæ¦‚å¿µï¼šå·¥å…·è°ƒç”¨ã€è®¡åˆ’åˆ†è§£ã€å¤šè½®æ¨ç†ã€çŠ¶æ€ç®¡ç†
- æ„å»ºå…·å¤‡æ£€ç´¢ã€è®¡ç®—ã€API è°ƒç”¨èƒ½åŠ›çš„å¤šåŠŸèƒ½ Agent
- ç”¨ LangGraph å®ç° Multi-Agent åä½œã€å†²çªè§£å†³ä¸ä»»åŠ¡ç¼–æ’
- é›†æˆä»£ç æ‰§è¡Œç¯å¢ƒï¼ˆæ²™ç®±ï¼‰ï¼Œæ”¯æŒæ•°æ®åˆ†æä¸è„šæœ¬ç”Ÿæˆ
- åœ¨ Next.js ä¸­æ„å»º Agent å¯¹è¯ç•Œé¢ï¼Œæ”¯æŒå·¥å…·é€‰æ‹©ä¸æ‰§è¡Œè¿‡ç¨‹å¯è§†åŒ–
- å®æˆ˜é¡¹ç›®ï¼šæ™ºèƒ½å®¢æœ Agentï¼ˆå¤šè½®å¯¹è¯ + çŸ¥è¯†æ£€ç´¢ + å·¥å•åˆ›å»ºï¼‰
- å·¥ç¨‹åŒ–ï¼šAgent å®‰å…¨ã€æ€§èƒ½ä¼˜åŒ–ã€å¯è§‚æµ‹æ€§ä¸é”™è¯¯æ¢å¤

---

## ğŸ¤– Agent åŸºç¡€æ¦‚å¿µä¸æ¶æ„

### 8.1 ä»€ä¹ˆæ˜¯ Agent
Agent æ˜¯å…·å¤‡ä»¥ä¸‹èƒ½åŠ›çš„ AI ç³»ç»Ÿï¼š
- **å·¥å…·è°ƒç”¨**ï¼šèƒ½ä½¿ç”¨å¤–éƒ¨å·¥å…·ï¼ˆæœç´¢ã€è®¡ç®—ã€APIï¼‰
- **è®¡åˆ’åˆ†è§£**ï¼šå°†å¤æ‚ä»»åŠ¡æ‹†è§£ä¸ºå¯æ‰§è¡Œçš„å­æ­¥éª¤
- **å¤šè½®æ¨ç†**ï¼šåŸºäºä¸­é—´ç»“æœè°ƒæ•´ç­–ç•¥ï¼Œè€Œéä¸€æ¬¡æ€§ç”Ÿæˆ
- **çŠ¶æ€ç®¡ç†**ï¼šç»´æŠ¤å¯¹è¯å†å²ã€å·¥å…·è°ƒç”¨è®°å½•ã€ä»»åŠ¡è¿›åº¦

### 8.2 Agent æ¶æ„æ¨¡å¼
```
ç”¨æˆ·è¾“å…¥ â†’ æ€è€ƒï¼ˆReasoningï¼‰â†’ å·¥å…·é€‰æ‹©ï¼ˆTool Selectionï¼‰â†’ å·¥å…·æ‰§è¡Œï¼ˆTool Executionï¼‰
  â†’ ç»“æœåˆ†æï¼ˆResult Analysisï¼‰â†’ ä¸‹ä¸€æ­¥å†³ç­–ï¼ˆNext Actionï¼‰â†’ è¾“å‡ºæˆ–ç»§ç»­å¾ªç¯
```

### 8.3 Agent ç±»å‹
- **ReAct Agent**ï¼šæ€è€ƒ-è¡ŒåŠ¨-è§‚å¯Ÿå¾ªç¯ï¼Œé€‚åˆå¤æ‚æ¨ç†
- **Tool-using Agent**ï¼šç›´æ¥å·¥å…·è°ƒç”¨ï¼Œé€‚åˆç»“æ„åŒ–ä»»åŠ¡
- **Multi-Agent**ï¼šå¤šä¸ª Agent åä½œï¼Œé€‚åˆå¤æ‚åœºæ™¯
- **Code Agent**ï¼šä»£ç ç”Ÿæˆä¸æ‰§è¡Œï¼Œé€‚åˆç¼–ç¨‹ä»»åŠ¡

---

## ğŸ› ï¸ å·¥å…·ç³»ç»Ÿï¼šå®šä¹‰ã€æ³¨å†Œä¸è°ƒç”¨

### 8.4 å·¥å…·å®šä¹‰ä¸ç±»å‹
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/tools.ts
import { Tool } from "@langchain/core/tools";
import { z } from "zod";

// åŸºç¡€å·¥å…·æ¥å£
export interface BaseTool {
  name: string;
  description: string;
  schema: z.ZodSchema;
  func: (...args: any[]) => Promise<any>;
}

// æœç´¢å·¥å…·
export class SearchTool extends Tool {
  name = "search";
  description = "æœç´¢ç½‘ç»œä¿¡æ¯ï¼Œè¾“å…¥æœç´¢å…³é”®è¯";
  schema = z.object({ query: z.string().describe("æœç´¢å…³é”®è¯") });

  async _call(input: { query: string }) {
    // æ¨¡æ‹Ÿæœç´¢ï¼Œå®é™…å¯æ¥å…¥ Google/Bing API
    return `æœç´¢ç»“æœï¼š${input.query} çš„ç›¸å…³ä¿¡æ¯...`;
  }
}

// è®¡ç®—å·¥å…·
export class CalculatorTool extends Tool {
  name = "calculator";
  description = "æ‰§è¡Œæ•°å­¦è®¡ç®—ï¼Œæ”¯æŒåŠ å‡ä¹˜é™¤å’ŒåŸºæœ¬å‡½æ•°";
  schema = z.object({ expression: z.string().describe("æ•°å­¦è¡¨è¾¾å¼ï¼Œå¦‚ 2+3*4") });

  async _call(input: { expression: string }) {
    try {
      // å®‰å…¨è®¡ç®—ï¼Œé¿å… eval
      const result = this.safeEval(input.expression);
      return `è®¡ç®—ç»“æœï¼š${result}`;
    } catch (error) {
      return `è®¡ç®—é”™è¯¯ï¼š${error}`;
    }
  }

  private safeEval(expr: string): number {
    // ç®€åŒ–çš„å®‰å…¨è®¡ç®—å®ç°
    const allowed = /^[0-9+\-*/().\s]+$/;
    if (!allowed.test(expr)) throw new Error("åŒ…å«éæ³•å­—ç¬¦");
    return Function(`"use strict"; return (${expr})`)();
  }
}

// æ—¶é—´å·¥å…·
export class TimeTool extends Tool {
  name = "get_time";
  description = "è·å–å½“å‰æ—¶é—´ä¿¡æ¯";
  schema = z.object({});

  async _call() {
    const now = new Date();
    return `å½“å‰æ—¶é—´ï¼š${now.toLocaleString('zh-CN')}`;
  }
}
```

### 8.5 å·¥å…·æ³¨å†Œä¸ç®¡ç†
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/tool-manager.ts
import { SearchTool, CalculatorTool, TimeTool } from "./tools";

export class ToolManager {
  private tools = new Map<string, any>();

  constructor() {
    this.register(new SearchTool());
    this.register(new CalculatorTool());
    this.register(new TimeTool());
  }

  register(tool: any) {
    this.tools.set(tool.name, tool);
  }

  getTool(name: string) {
    return this.tools.get(name);
  }

  getAllTools() {
    return Array.from(this.tools.values());
  }

  async execute(name: string, args: any) {
    const tool = this.getTool(name);
    if (!tool) throw new Error(`å·¥å…· ${name} ä¸å­˜åœ¨`);
    return await tool._call(args);
  }
}
```

---

## ğŸ§  ReAct Agentï¼šæ€è€ƒ-è¡ŒåŠ¨-è§‚å¯Ÿå¾ªç¯

### 8.6 ReAct æ¨¡å¼å®ç°
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/react-agent.ts
import { ChatOpenAI } from "@langchain/openai";
import { PromptTemplate } from "@langchain/core/prompts";
import { ToolManager } from "./tool-manager";

export type AgentState = {
  question: string;
  thought: string;
  action: string;
  actionInput: any;
  observation: string;
  answer: string;
  step: number;
};

export class ReActAgent {
  private llm: ChatOpenAI;
  private tools: ToolManager;
  private maxSteps = 5;

  constructor() {
    this.llm = new ChatOpenAI({ temperature: 0 });
    this.tools = new ToolManager();
  }

  private getPrompt() {
    return PromptTemplate.fromTemplate(`
ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½åŠ©æ‰‹ï¼Œå¯ä»¥è°ƒç”¨å·¥å…·æ¥å®Œæˆä»»åŠ¡ã€‚

å¯ç”¨å·¥å…·ï¼š
{tools}

æ€è€ƒè¿‡ç¨‹ï¼š
1. åˆ†æé—®é¢˜ï¼Œç¡®å®šéœ€è¦ä½¿ç”¨çš„å·¥å…·
2. è°ƒç”¨å·¥å…·è·å–ä¿¡æ¯
3. åŸºäºç»“æœç»§ç»­æ€è€ƒæˆ–ç»™å‡ºæœ€ç»ˆç­”æ¡ˆ

æ ¼å¼ï¼š
æ€è€ƒï¼š<ä½ çš„æ¨ç†è¿‡ç¨‹>
è¡ŒåŠ¨ï¼š<å·¥å…·åç§°>
è¡ŒåŠ¨è¾“å…¥ï¼š<å·¥å…·å‚æ•°>
è§‚å¯Ÿï¼š<å·¥å…·è¿”å›ç»“æœ>
... (å¯ä»¥é‡å¤æ€è€ƒ-è¡ŒåŠ¨-è§‚å¯Ÿ)
æ€è€ƒï¼š<æœ€ç»ˆæ¨ç†>
æœ€ç»ˆç­”æ¡ˆï¼š<ç»™ç”¨æˆ·çš„ç­”æ¡ˆ>

é—®é¢˜ï¼š{question}
æ€è€ƒï¼š`);
  }

  async run(question: string): Promise<AgentState[]> {
    const steps: AgentState[] = [];
    let currentThought = "";
    let step = 0;

    while (step < this.maxSteps) {
      const prompt = this.getPrompt();
      const toolsDesc = this.tools.getAllTools()
        .map(t => `${t.name}: ${t.description}`)
        .join("\n");

      const response = await prompt.pipe(this.llm).invoke({
        question,
        tools: toolsDesc,
        thought: currentThought
      });

      const content = response.content as string;

      // è§£æå“åº”ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„è§£æï¼‰
      const thoughtMatch = content.match(/æ€è€ƒï¼š(.*?)(?=\n|$)/);
      const actionMatch = content.match(/è¡ŒåŠ¨ï¼š(.*?)(?=\n|$)/);
      const inputMatch = content.match(/è¡ŒåŠ¨è¾“å…¥ï¼š(.*?)(?=\n|$)/);
      const answerMatch = content.match(/æœ€ç»ˆç­”æ¡ˆï¼š(.*?)(?=\n|$)/);

      if (answerMatch) {
        steps.push({
          question,
          thought: thoughtMatch?.[1] || "",
          action: "",
          actionInput: {},
          observation: "",
          answer: answerMatch[1],
          step
        });
        break;
      }

      if (actionMatch && inputMatch) {
        const action = actionMatch[1].trim();
        const actionInput = JSON.parse(inputMatch[1]);

        // æ‰§è¡Œå·¥å…·
        const observation = await this.tools.execute(action, actionInput);

        steps.push({
          question,
          thought: thoughtMatch?.[1] || "",
          action,
          actionInput,
          observation,
          answer: "",
          step
        });

        currentThought += `\næ€è€ƒï¼š${thoughtMatch?.[1]}\nè¡ŒåŠ¨ï¼š${action}\nè§‚å¯Ÿï¼š${observation}\n`;
        step++;
      } else {
        break;
      }
    }

    return steps;
  }
}
```

### 8.7 æ”¹è¿›çš„å“åº”è§£æ
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/parser.ts
export function parseReActResponse(content: string) {
  const lines = content.split('\n');
  const result: any = {};

  for (const line of lines) {
    if (line.startsWith('æ€è€ƒï¼š')) {
      result.thought = line.slice(3).trim();
    } else if (line.startsWith('è¡ŒåŠ¨ï¼š')) {
      result.action = line.slice(3).trim();
    } else if (line.startsWith('è¡ŒåŠ¨è¾“å…¥ï¼š')) {
      try {
        result.actionInput = JSON.parse(line.slice(5).trim());
      } catch {
        result.actionInput = line.slice(5).trim();
      }
    } else if (line.startsWith('è§‚å¯Ÿï¼š')) {
      result.observation = line.slice(3).trim();
    } else if (line.startsWith('æœ€ç»ˆç­”æ¡ˆï¼š')) {
      result.answer = line.slice(5).trim();
    }
  }

  return result;
}
```

---

## ğŸ”§ ä»£ç æ‰§è¡Œ Agentï¼šæ²™ç®±ç¯å¢ƒ

### 8.8 ä»£ç æ‰§è¡Œå·¥å…·
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/code-tools.ts
import { Tool } from "@langchain/core/tools";
import { z } from "zod";

export class CodeExecutionTool extends Tool {
  name = "execute_code";
  description = "æ‰§è¡Œ Python ä»£ç ï¼Œæ”¯æŒæ•°æ®åˆ†æã€å›¾è¡¨ç”Ÿæˆç­‰";
  schema = z.object({
    code: z.string().describe("è¦æ‰§è¡Œçš„ Python ä»£ç "),
    language: z.enum(["python"]).default("python").describe("ç¼–ç¨‹è¯­è¨€")
  });

  private sandbox = new Map<string, any>();

  async _call(input: { code: string; language: string }) {
    if (input.language !== "python") {
      return "ç›®å‰åªæ”¯æŒ Python ä»£ç æ‰§è¡Œ";
    }

    try {
      // ç®€åŒ–çš„ Python ä»£ç æ‰§è¡Œï¼ˆå®é™…åº”ä½¿ç”¨å®‰å…¨çš„æ²™ç®±ï¼‰
      const result = await this.executePython(input.code);
      return `æ‰§è¡Œç»“æœï¼š\n${result}`;
    } catch (error) {
      return `æ‰§è¡Œé”™è¯¯ï¼š${error}`;
    }
  }

  private async executePython(code: string): Promise<string> {
    // å®‰å…¨æ£€æŸ¥
    const dangerous = ['import os', 'import sys', 'eval(', 'exec(', '__import__'];
    for (const d of dangerous) {
      if (code.includes(d)) {
        throw new Error(`ç¦æ­¢ä½¿ç”¨ï¼š${d}`);
      }
    }

    // æ¨¡æ‹Ÿæ‰§è¡Œï¼ˆå®é™…åº”ä½¿ç”¨å®‰å…¨çš„ Python è¿è¡Œæ—¶ï¼‰
    if (code.includes('print(')) {
      return "æ¨¡æ‹Ÿè¾“å‡ºï¼šä»£ç æ‰§è¡ŒæˆåŠŸ";
    } else if (code.includes('import pandas')) {
      return "pandas å·²å¯¼å…¥ï¼Œå¯ä»¥è¿›è¡Œæ•°æ®åˆ†æ";
    } else if (code.includes('import matplotlib')) {
      return "matplotlib å·²å¯¼å…¥ï¼Œå¯ä»¥ç”Ÿæˆå›¾è¡¨";
    }

    return "ä»£ç æ‰§è¡Œå®Œæˆ";
  }
}

// æ•°æ®åˆ†æå·¥å…·
export class DataAnalysisTool extends Tool {
  name = "analyze_data";
  description = "åˆ†ææ•°æ®ï¼Œç”Ÿæˆç»Ÿè®¡ä¿¡æ¯å’Œå¯è§†åŒ–";
  schema = z.object({
    data: z.string().describe("CSV æ ¼å¼çš„æ•°æ®æˆ–æ•°æ®æè¿°"),
    analysis_type: z.enum(["summary", "visualization", "correlation"]).describe("åˆ†æç±»å‹")
  });

  async _call(input: { data: string; analysis_type: string }) {
    const code = this.generateAnalysisCode(input.data, input.analysis_type);
    const execTool = new CodeExecutionTool();
    return await execTool._call({ code, language: "python" });
  }

  private generateAnalysisCode(data: string, type: string): string {
    switch (type) {
      case "summary":
        return `
import pandas as pd
import numpy as np
# å‡è®¾æ•°æ®å·²åŠ è½½
print("æ•°æ®æ¦‚è§ˆï¼š")
print(f"è¡Œæ•°ï¼š{len(data)}")
print(f"åˆ—æ•°ï¼š{len(data.columns)}")
print("\\nç»Ÿè®¡æ‘˜è¦ï¼š")
print(data.describe())
`;
      case "visualization":
        return `
import matplotlib.pyplot as plt
import seaborn as sns
# ç”Ÿæˆç¤ºä¾‹å›¾è¡¨
plt.figure(figsize=(10, 6))
plt.title("æ•°æ®å¯è§†åŒ–")
plt.show()
`;
      default:
        return "print('åˆ†æå®Œæˆ')";
    }
  }
}
```

---

## ğŸ¤ Multi-Agent åä½œç³»ç»Ÿ

### 8.9 Agent è§’è‰²å®šä¹‰
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/multi-agent.ts
import { ChatOpenAI } from "@langchain/openai";
import { PromptTemplate } from "@langchain/core/prompts";

export interface AgentRole {
  name: string;
  description: string;
  expertise: string[];
  tools: string[];
}

export const AGENT_ROLES: AgentRole[] = [
  {
    name: "ç ”ç©¶å‘˜",
    description: "è´Ÿè´£ä¿¡æ¯æ”¶é›†å’Œäº‹å®æ ¸æŸ¥",
    expertise: ["æœç´¢", "éªŒè¯", "æ€»ç»“"],
    tools: ["search", "get_time"]
  },
  {
    name: "åˆ†æå¸ˆ",
    description: "è´Ÿè´£æ•°æ®åˆ†æå’Œæ´å¯Ÿ",
    expertise: ["è®¡ç®—", "ç»Ÿè®¡", "å¯è§†åŒ–"],
    tools: ["calculator", "analyze_data"]
  },
  {
    name: "åè°ƒå‘˜",
    description: "è´Ÿè´£ä»»åŠ¡åˆ†é…å’Œç»“æœæ•´åˆ",
    expertise: ["è§„åˆ’", "åè°ƒ", "æ€»ç»“"],
    tools: ["get_time"]
  }
];

export class MultiAgentSystem {
  private agents: Map<string, any> = new Map();
  private llm: ChatOpenAI;

  constructor() {
    this.llm = new ChatOpenAI({ temperature: 0.7 });
    this.initializeAgents();
  }

  private initializeAgents() {
    for (const role of AGENT_ROLES) {
      this.agents.set(role.name, {
        role,
        llm: new ChatOpenAI({ temperature: 0.5 }),
        prompt: this.createRolePrompt(role)
      });
    }
  }

  private createRolePrompt(role: AgentRole) {
    return PromptTemplate.fromTemplate(`
ä½ æ˜¯ ${role.name}ï¼Œ${role.description}

ä½ çš„ä¸“é•¿ï¼š${role.expertise.join(", ")}
å¯ç”¨å·¥å…·ï¼š${role.tools.join(", ")}

ä»»åŠ¡ï¼š{task}
å½“å‰çŠ¶æ€ï¼š{state}
å…¶ä»– Agent çš„æ„è§ï¼š{other_opinions}

è¯·åŸºäºä½ çš„ä¸“é•¿æä¾›å»ºè®®æˆ–æ‰§è¡Œä»»åŠ¡ï¼š
`);
  }

  async collaborate(task: string): Promise<any> {
    const results: any = {};
    const opinions: string[] = [];

    // ç¬¬ä¸€è½®ï¼šå„ Agent ç‹¬ç«‹åˆ†æ
    for (const [name, agent] of this.agents) {
      const response = await agent.prompt.pipe(agent.llm).invoke({
        task,
        state: "åˆå§‹åˆ†æé˜¶æ®µ",
        other_opinions: "æš‚æ— "
      });

      results[name] = response.content;
      opinions.push(`${name}: ${response.content}`);
    }

    // ç¬¬äºŒè½®ï¼šåŸºäºå…¶ä»– Agent æ„è§è°ƒæ•´
    for (const [name, agent] of this.agents) {
      const otherOpinions = opinions.filter(o => !o.startsWith(name));
      const response = await agent.prompt.pipe(agent.llm).invoke({
        task,
        state: "åä½œè°ƒæ•´é˜¶æ®µ",
        other_opinions: otherOpinions.join("\n")
      });

      results[`${name}_final`] = response.content;
    }

    // æœ€ç»ˆæ•´åˆ
    const coordinator = this.agents.get("åè°ƒå‘˜");
    const finalResponse = await coordinator.prompt.pipe(coordinator.llm).invoke({
      task,
      state: "æœ€ç»ˆæ•´åˆ",
      other_opinions: Object.entries(results).map(([k, v]) => `${k}: ${v}`).join("\n")
    });

    return {
      individual_results: results,
      final_answer: finalResponse.content
    };
  }
}
```

---

## ğŸŒ Next.js é›†æˆï¼šAgent å¯¹è¯ç•Œé¢

### 8.10 Agent API æ¥å£
```typescript
// æ–‡ä»¶ï¼šsrc/app/api/agent/route.ts
import { NextRequest } from "next/server";
import { ReActAgent } from "@/src/ch08/react-agent";
import { MultiAgentSystem } from "@/src/ch08/multi-agent";

export const runtime = "edge";

export async function POST(req: NextRequest) {
  const { message, agentType = "react" } = await req.json();

  try {
    let result;

    if (agentType === "react") {
      const agent = new ReActAgent();
      result = await agent.run(message);
    } else if (agentType === "multi") {
      const system = new MultiAgentSystem();
      result = await system.collaborate(message);
    } else {
      return Response.json({ error: "ä¸æ”¯æŒçš„ Agent ç±»å‹" }, { status: 400 });
    }

    return Response.json({ success: true, data: result });
  } catch (error: any) {
    return Response.json({ error: error.message }, { status: 500 });
  }
}
```

### 8.11 å‰ç«¯å¯¹è¯ç•Œé¢
```tsx
// æ–‡ä»¶ï¼šsrc/app/agent/page.tsx
"use client";
import { useState, useRef, useEffect } from "react";

interface Message {
  id: string;
  type: "user" | "agent";
  content: string;
  steps?: any[];
  timestamp: Date;
}

export default function AgentPage() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");
  const [agentType, setAgentType] = useState("react");
  const [loading, setLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const sendMessage = async () => {
    if (!input.trim() || loading) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      type: "user",
      content: input,
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInput("");
    setLoading(true);

    try {
      const response = await fetch("/api/agent", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message: input, agentType })
      });

      const result = await response.json();

      if (result.success) {
        const agentMessage: Message = {
          id: (Date.now() + 1).toString(),
          type: "agent",
          content: agentType === "react"
            ? result.data[result.data.length - 1]?.answer || "å¤„ç†å®Œæˆ"
            : result.data.final_answer,
          steps: agentType === "react" ? result.data : undefined,
          timestamp: new Date()
        };
        setMessages(prev => [...prev, agentMessage]);
      } else {
        throw new Error(result.error);
      }
    } catch (error: any) {
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        type: "agent",
        content: `é”™è¯¯ï¼š${error.message}`,
        timestamp: new Date()
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setLoading(false);
    }
  };

  const renderStep = (step: any, index: number) => (
    <div key={index} className="ml-4 mb-2 p-2 bg-gray-50 rounded">
      <div className="text-sm text-gray-600">æ­¥éª¤ {step.step + 1}</div>
      {step.thought && <div className="text-sm">æ€è€ƒï¼š{step.thought}</div>}
      {step.action && <div className="text-sm">è¡ŒåŠ¨ï¼š{step.action}</div>}
      {step.observation && <div className="text-sm">è§‚å¯Ÿï¼š{step.observation}</div>}
    </div>
  );

  return (
    <div className="max-w-4xl mx-auto h-screen flex flex-col">
      <div className="p-4 border-b">
        <h1 className="text-2xl font-bold mb-4">æ™ºèƒ½ Agent å¯¹è¯</h1>
        <div className="flex gap-4">
          <select
            value={agentType}
            onChange={(e) => setAgentType(e.target.value)}
            className="border rounded px-3 py-1"
          >
            <option value="react">ReAct Agent</option>
            <option value="multi">Multi-Agent</option>
          </select>
        </div>
      </div>

      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((message) => (
          <div key={message.id} className={`flex ${message.type === "user" ? "justify-end" : "justify-start"}`}>
            <div className={`max-w-3xl p-3 rounded-lg ${
              message.type === "user"
                ? "bg-blue-500 text-white"
                : "bg-gray-100"
            }`}>
              <div className="whitespace-pre-wrap">{message.content}</div>
              {message.steps && (
                <div className="mt-2">
                  <div className="text-sm font-semibold mb-2">æ‰§è¡Œæ­¥éª¤ï¼š</div>
                  {message.steps.map(renderStep)}
                </div>
              )}
              <div className="text-xs opacity-70 mt-1">
                {message.timestamp.toLocaleTimeString()}
              </div>
            </div>
          </div>
        ))}
        {loading && (
          <div className="flex justify-start">
            <div className="bg-gray-100 p-3 rounded-lg">
              <div className="flex items-center gap-2">
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900"></div>
                Agent æ­£åœ¨æ€è€ƒ...
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <div className="p-4 border-t">
        <div className="flex gap-2">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === "Enter" && sendMessage()}
            placeholder="è¾“å…¥ä½ çš„é—®é¢˜..."
            className="flex-1 border rounded px-3 py-2"
            disabled={loading}
          />
          <button
            onClick={sendMessage}
            disabled={loading || !input.trim()}
            className="px-4 py-2 bg-blue-500 text-white rounded disabled:opacity-50"
          >
            å‘é€
          </button>
        </div>
      </div>
    </div>
  );
}
```

---

## ğŸš€ å®æˆ˜é¡¹ç›®ï¼šæ™ºèƒ½å®¢æœ Agent

### 8.12 é¡¹ç›®éœ€æ±‚
- **å¤šè½®å¯¹è¯**ï¼šç†è§£ä¸Šä¸‹æ–‡ï¼Œæ”¯æŒè¿½é—®å’Œæ¾„æ¸…
- **çŸ¥è¯†æ£€ç´¢**ï¼šé›†æˆ RAG ç³»ç»Ÿï¼Œæä¾›å‡†ç¡®ç­”æ¡ˆ
- **å·¥å•åˆ›å»º**ï¼šå¤æ‚é—®é¢˜è‡ªåŠ¨åˆ›å»ºå·¥å•
- **æƒ…æ„Ÿåˆ†æ**ï¼šè¯†åˆ«ç”¨æˆ·æƒ…ç»ªï¼Œè°ƒæ•´å›å¤ç­–ç•¥
- **æ„å›¾è¯†åˆ«**ï¼šåˆ†ç±»ç”¨æˆ·æ„å›¾ï¼ˆå’¨è¯¢ã€æŠ•è¯‰ã€å»ºè®®ç­‰ï¼‰

### 8.13 å®¢æœ Agent å®ç°
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/customer-service-agent.ts
import { ChatOpenAI } from "@langchain/openai";
import { PromptTemplate } from "@langchain/core/prompts";
import { ToolManager } from "./tool-manager";

export interface CustomerIntent {
  type: "query" | "complaint" | "suggestion" | "escalation";
  confidence: number;
  entities: Record<string, any>;
}

export class CustomerServiceAgent {
  private llm: ChatOpenAI;
  private tools: ToolManager;
  private memory: any[] = [];

  constructor() {
    this.llm = new ChatOpenAI({ temperature: 0.3 });
    this.tools = new ToolManager();
  }

  private async analyzeIntent(message: string): Promise<CustomerIntent> {
    const prompt = PromptTemplate.fromTemplate(`
åˆ†æç”¨æˆ·æ„å›¾ï¼Œè¾“å‡º JSONï¼š
{
  "type": "query|complaint|suggestion|escalation",
  "confidence": 0.0-1.0,
  "entities": {
    "product": "äº§å“åç§°",
    "issue": "é—®é¢˜æè¿°",
    "urgency": "ç´§æ€¥ç¨‹åº¦"
  }
}

ç”¨æˆ·æ¶ˆæ¯ï¼š{message}
å†å²å¯¹è¯ï¼š{history}
`);

    const response = await prompt.pipe(this.llm).invoke({
      message,
      history: this.memory.slice(-3).map(m => `${m.role}: ${m.content}`).join("\n")
    });

    return JSON.parse(response.content as string);
  }

  private async generateResponse(
    message: string,
    intent: CustomerIntent,
    context: any
  ): Promise<string> {
    const prompt = PromptTemplate.fromTemplate(`
ä½ æ˜¯ä¸“ä¸šçš„å®¢æœä»£è¡¨ï¼ŒåŸºäºç”¨æˆ·æ„å›¾å’Œä¸Šä¸‹æ–‡ç”Ÿæˆå›å¤ã€‚

ç”¨æˆ·æ„å›¾ï¼š{intent}
ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼š{context}
å†å²å¯¹è¯ï¼š{history}

è¦æ±‚ï¼š
1. è¯­æ°”å‹å¥½ä¸“ä¸š
2. é’ˆå¯¹æ„å›¾ç±»å‹è°ƒæ•´å›å¤ç­–ç•¥
3. æä¾›å…·ä½“è§£å†³æ–¹æ¡ˆ
4. å¿…è¦æ—¶å¼•å¯¼ç”¨æˆ·æä¾›æ›´å¤šä¿¡æ¯

ç”¨æˆ·æ¶ˆæ¯ï¼š{message}
å›å¤ï¼š`);

    const response = await prompt.pipe(this.llm).invoke({
      message,
      intent: JSON.stringify(intent),
      context: JSON.stringify(context),
      history: this.memory.slice(-3).map(m => `${m.role}: ${m.content}`).join("\n")
    });

    return response.content as string;
  }

  async processMessage(message: string): Promise<{
    response: string;
    intent: CustomerIntent;
    actions: string[];
    shouldEscalate: boolean;
  }> {
    // 1. æ„å›¾åˆ†æ
    const intent = await this.analyzeIntent(message);

    // 2. æ ¹æ®æ„å›¾æ‰§è¡Œç›¸åº”å·¥å…·
    const actions: string[] = [];
    let context: any = {};

    if (intent.type === "query") {
      // çŸ¥è¯†æ£€ç´¢
      const searchResult = await this.tools.execute("search", {
        query: message
      });
      context.searchResult = searchResult;
      actions.push("çŸ¥è¯†æ£€ç´¢");
    }

    if (intent.confidence < 0.7) {
      // ä½ç½®ä¿¡åº¦ï¼Œéœ€è¦æ¾„æ¸…
      context.needsClarification = true;
      actions.push("è¯·æ±‚æ¾„æ¸…");
    }

    // 3. ç”Ÿæˆå›å¤
    const response = await this.generateResponse(message, intent, context);

    // 4. æ›´æ–°è®°å¿†
    this.memory.push({ role: "user", content: message });
    this.memory.push({ role: "assistant", content: response });

    // 5. åˆ¤æ–­æ˜¯å¦éœ€è¦å‡çº§
    const shouldEscalate = intent.type === "escalation" ||
                          (intent.type === "complaint" && intent.confidence > 0.8);

    return {
      response,
      intent,
      actions,
      shouldEscalate
    };
  }

  async createTicket(userInfo: any, issue: string): Promise<string> {
    // æ¨¡æ‹Ÿå·¥å•åˆ›å»º
    const ticketId = `TKT-${Date.now()}`;
    console.log(`åˆ›å»ºå·¥å• ${ticketId}:`, { userInfo, issue });
    return ticketId;
  }
}
```

### 8.14 å®¢æœ API æ¥å£
```typescript
// æ–‡ä»¶ï¼šsrc/app/api/customer-service/route.ts
import { NextRequest } from "next/server";
import { CustomerServiceAgent } from "@/src/ch08/customer-service-agent";

export const runtime = "edge";

export async function POST(req: NextRequest) {
  const { message, sessionId } = await req.json();

  try {
    const agent = new CustomerServiceAgent();
    const result = await agent.processMessage(message);

    // å¦‚æœéœ€è¦å‡çº§ï¼Œåˆ›å»ºå·¥å•
    let ticketId = null;
    if (result.shouldEscalate) {
      ticketId = await agent.createTicket(
        { sessionId },
        `ç”¨æˆ·é—®é¢˜ï¼š${message}\næ„å›¾ï¼š${JSON.stringify(result.intent)}`
      );
    }

    return Response.json({
      success: true,
      data: {
        ...result,
        ticketId
      }
    });
  } catch (error: any) {
    return Response.json({ error: error.message }, { status: 500 });
  }
}
```

---

## âš™ï¸ å·¥ç¨‹åŒ–ä¸ä¼˜åŒ–

### 8.15 Agent å®‰å…¨ä¸é˜²æŠ¤
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/security.ts
export class AgentSecurity {
  private blacklist = [
    "rm -rf", "format", "delete", "drop", "exec", "eval",
    "password", "token", "key", "secret"
  ];

  private rateLimit = new Map<string, number[]>();

  validateInput(input: string): { valid: boolean; reason?: string } {
    // æ•æ„Ÿè¯æ£€æŸ¥
    for (const word of this.blacklist) {
      if (input.toLowerCase().includes(word)) {
        return { valid: false, reason: `åŒ…å«æ•æ„Ÿè¯ï¼š${word}` };
      }
    }

    // é•¿åº¦é™åˆ¶
    if (input.length > 1000) {
      return { valid: false, reason: "è¾“å…¥è¿‡é•¿" };
    }

    return { valid: true };
  }

  checkRateLimit(userId: string, limit = 10, window = 60000): boolean {
    const now = Date.now();
    const userRequests = this.rateLimit.get(userId) || [];

    // æ¸…ç†è¿‡æœŸè¯·æ±‚
    const validRequests = userRequests.filter(time => now - time < window);

    if (validRequests.length >= limit) {
      return false;
    }

    validRequests.push(now);
    this.rateLimit.set(userId, validRequests);
    return true;
  }
}
```

### 8.16 æ€§èƒ½ä¼˜åŒ–
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/optimization.ts
export class AgentOptimizer {
  private cache = new Map<string, any>();
  private toolCache = new Map<string, any>();

  async cachedToolCall(toolName: string, args: any, ttl = 300000): Promise<any> {
    const key = `${toolName}:${JSON.stringify(args)}`;
    const cached = this.toolCache.get(key);

    if (cached && Date.now() - cached.timestamp < ttl) {
      return cached.result;
    }

    // å®é™…è°ƒç”¨å·¥å…·
    const result = await this.executeTool(toolName, args);

    this.toolCache.set(key, {
      result,
      timestamp: Date.now()
    });

    return result;
  }

  private async executeTool(toolName: string, args: any): Promise<any> {
    // å·¥å…·æ‰§è¡Œé€»è¾‘
    return `Tool ${toolName} executed with ${JSON.stringify(args)}`;
  }

  // å¹¶è¡Œå·¥å…·è°ƒç”¨
  async parallelToolCalls(calls: Array<{ tool: string; args: any }>): Promise<any[]> {
    const promises = calls.map(call => this.cachedToolCall(call.tool, call.args));
    return Promise.all(promises);
  }
}
```

### 8.17 å¯è§‚æµ‹æ€§ä¸ç›‘æ§
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/monitoring.ts
export interface AgentMetrics {
  requestId: string;
  userId: string;
  agentType: string;
  startTime: number;
  endTime: number;
  toolCalls: Array<{ tool: string; duration: number; success: boolean }>;
  totalTokens: number;
  error?: string;
}

export class AgentMonitor {
  private metrics: AgentMetrics[] = [];

  startRequest(requestId: string, userId: string, agentType: string): AgentMetrics {
    const metric: AgentMetrics = {
      requestId,
      userId,
      agentType,
      startTime: Date.now(),
      endTime: 0,
      toolCalls: [],
      totalTokens: 0
    };

    this.metrics.push(metric);
    return metric;
  }

  recordToolCall(requestId: string, tool: string, duration: number, success: boolean) {
    const metric = this.metrics.find(m => m.requestId === requestId);
    if (metric) {
      metric.toolCalls.push({ tool, duration, success });
    }
  }

  endRequest(requestId: string, totalTokens: number, error?: string) {
    const metric = this.metrics.find(m => m.requestId === requestId);
    if (metric) {
      metric.endTime = Date.now();
      metric.totalTokens = totalTokens;
      metric.error = error;
    }
  }

  getMetrics(): AgentMetrics[] {
    return this.metrics;
  }

  getAverageResponseTime(): number {
    const completed = this.metrics.filter(m => m.endTime > 0);
    if (completed.length === 0) return 0;

    const total = completed.reduce((sum, m) => sum + (m.endTime - m.startTime), 0);
    return total / completed.length;
  }
}
```

---

## ğŸ§ª æµ‹è¯•ä¸è¯„ä¼°

### 8.18 Agent æµ‹è¯•æ¡†æ¶
```typescript
// æ–‡ä»¶ï¼šsrc/ch08/testing.ts
export interface TestCase {
  id: string;
  input: string;
  expectedIntent?: string;
  expectedTools?: string[];
  expectedResponse?: string;
  maxSteps?: number;
}

export class AgentTester {
  constructor(private agent: any) {}

  async runTest(testCase: TestCase): Promise<{
    passed: boolean;
    actual: any;
    expected: any;
    duration: number;
  }> {
    const startTime = Date.now();

    try {
      const result = await this.agent.processMessage(testCase.input);
      const duration = Date.now() - startTime;

      const passed = this.evaluateResult(result, testCase);

      return {
        passed,
        actual: result,
        expected: testCase,
        duration
      };
    } catch (error) {
      return {
        passed: false,
        actual: { error: error.message },
        expected: testCase,
        duration: Date.now() - startTime
      };
    }
  }

  private evaluateResult(actual: any, expected: TestCase): boolean {
    if (expected.expectedIntent && actual.intent?.type !== expected.expectedIntent) {
      return false;
    }

    if (expected.expectedTools) {
      const actualTools = actual.actions || [];
      for (const tool of expected.expectedTools) {
        if (!actualTools.includes(tool)) {
          return false;
        }
      }
    }

    if (expected.expectedResponse && !actual.response.includes(expected.expectedResponse)) {
      return false;
    }

    return true;
  }

  async runTestSuite(testCases: TestCase[]): Promise<{
    total: number;
    passed: number;
    failed: number;
    results: any[];
  }> {
    const results = await Promise.all(
      testCases.map(testCase => this.runTest(testCase))
    );

    const passed = results.filter(r => r.passed).length;
    const failed = results.length - passed;

    return {
      total: results.length,
      passed,
      failed,
      results
    };
  }
}
```

---

## ğŸ“š å»¶ä¼¸é“¾æ¥
- LangChain.js Agent æ–‡æ¡£ï¼š`https://js.langchain.com/docs/use_cases/autonomous_agents/`
- LangGraph çŠ¶æ€å›¾ï¼š`https://langchain-ai.github.io/langgraph/`
- ReAct è®ºæ–‡ï¼š`https://arxiv.org/abs/2210.03629`
- Agent å®‰å…¨æœ€ä½³å®è·µï¼š`https://github.com/langchain-ai/langchain/tree/master/libs/langchain/langchain/agents`

---

## âœ… æœ¬ç« å°ç»“
- æ„å»ºäº†å®Œæ•´çš„ Agent ç³»ç»Ÿï¼šå·¥å…·å®šä¹‰ã€ReAct å¾ªç¯ã€å¤š Agent åä½œ
- å®ç°äº†ä»£ç æ‰§è¡Œç¯å¢ƒä¸æ•°æ®åˆ†æèƒ½åŠ›
- åœ¨ Next.js ä¸­æä¾›äº†å®Œæ•´çš„ Agent å¯¹è¯ç•Œé¢
- å®æˆ˜äº†æ™ºèƒ½å®¢æœ Agentï¼Œå…·å¤‡æ„å›¾è¯†åˆ«ã€çŸ¥è¯†æ£€ç´¢ã€å·¥å•åˆ›å»ºèƒ½åŠ›
- å»ºç«‹äº†å®‰å…¨ã€æ€§èƒ½ã€å¯è§‚æµ‹æ€§çš„å·¥ç¨‹åŒ–ä½“ç³»

## ğŸ¯ ä¸‹ç« é¢„å‘Š
ä¸‹ä¸€ç« ã€ŠLangGraph çŠ¶æ€å›¾ä¸å·¥ä½œæµç¼–æ’ã€‹ä¸­ï¼Œæˆ‘ä»¬å°†ï¼š
- æ·±å…¥ LangGraph çŠ¶æ€å›¾è®¾è®¡æ¨¡å¼
- æ„å»ºå¤æ‚çš„å·¥ä½œæµç¼–æ’ç³»ç»Ÿ
- å®ç°æ¡ä»¶åˆ†æ”¯ã€å¾ªç¯ã€å¹¶è¡Œå¤„ç†
- é›†æˆå¤–éƒ¨ API ä¸æ•°æ®åº“æ“ä½œ

> æœ€åæ„Ÿè°¢é˜…è¯»ï¼æ¬¢è¿å…³æ³¨æˆ‘ï¼Œå¾®ä¿¡å…¬ä¼—å·ï¼š`ã€Šé²«å°é±¼ä¸æ­£ç»ã€‹`ã€‚æ¬¢è¿ç‚¹èµã€æ”¶è—ã€å…³æ³¨ï¼Œä¸€é”®ä¸‰è¿ï¼ï¼ï¼

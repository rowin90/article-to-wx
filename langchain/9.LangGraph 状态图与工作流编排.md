# ç¬¬9ç« ï¼šLangGraph çŠ¶æ€å›¾ä¸å·¥ä½œæµç¼–æ’

# å‰è¨€
å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯é²«å°é±¼ã€‚æ˜¯ä¸€å`ä¸å†™å‰ç«¯ä»£ç `çš„å‰ç«¯å·¥ç¨‹å¸ˆï¼Œçƒ­è¡·äºåˆ†äº«éå‰ç«¯çš„çŸ¥è¯†ï¼Œå¸¦é¢†åˆ‡å›¾ä»”é€ƒç¦»åˆ‡å›¾åœˆå­ï¼Œæ¬¢è¿å…³æ³¨æˆ‘ï¼Œå¾®ä¿¡å…¬ä¼—å·ï¼š`ã€Šé²«å°é±¼ä¸æ­£ç»ã€‹`ã€‚æ¬¢è¿ç‚¹èµã€æ”¶è—ã€å…³æ³¨ï¼Œä¸€é”®ä¸‰è¿ï¼ï¼

## ğŸ¯ æœ¬ç« å­¦ä¹ ç›®æ ‡
- å…¨é¢æŒæ¡ LangGraph 0.3 çš„æ ¸å¿ƒæ¦‚å¿µï¼šçŠ¶æ€ï¼ˆStateï¼‰ã€é€šé“ï¼ˆChannelsï¼‰ã€èŠ‚ç‚¹ï¼ˆNodesï¼‰ã€è¾¹ï¼ˆEdgesï¼‰ã€ç¼–è¯‘ï¼ˆCompileï¼‰
- æŒæ¡åˆ†æ”¯ï¼ˆBranchï¼‰ã€å¾ªç¯ï¼ˆLoopï¼‰ã€å¹¶è¡Œï¼ˆParallelï¼‰ã€ä¸­æ–­ï¼ˆInterruptï¼‰ç­‰å·¥ä½œæµç¼–æ’èƒ½åŠ›
- å°† Runnableã€Memoryã€Callback ä¸ LangGraph æ·±åº¦ç»“åˆï¼Œæ„å»ºå¯è§‚æµ‹ä¸å¯æ¢å¤çš„é•¿æµç¨‹
- æŒæ¡äººæœºååŒï¼šäººå·¥å®¡æ‰¹ / å®¡æ ¸èŠ‚ç‚¹ã€æ–­ç‚¹æ¢å¤ã€å¯å›æ”¾æ‰§è¡Œ
- åœ¨ Next.js ä¸­æ„å»ºâ€œæµç¨‹å¼•æ“ APIâ€ï¼Œå¹¶æä¾›å‰ç«¯å¯è§†åŒ–â€œçŠ¶æ€å›¾æŸ¥çœ‹å™¨â€
- å®æˆ˜ï¼šæ„å»ºâ€œçŸ¥è¯†å…¥åº“ï¼ˆIngestï¼‰+ RAG é—®ç­” + åé¦ˆé—­ç¯â€çš„ç«¯åˆ°ç«¯æµç¨‹

---

## ğŸ§  LangGraph åŸºæœ¬æ¦‚å¿µä¸æ¨¡å‹

### 9.1 ä¸ºä»€ä¹ˆéœ€è¦ LangGraph
- Runnable æ›´åƒâ€œå‡½æ•°ç®¡é“â€ï¼›å½“æµç¨‹å¤æ‚ï¼ˆå¤šåˆ†æ”¯/å¾ªç¯/è·¨è¯·æ±‚ï¼‰æ—¶ï¼Œç»´æŠ¤æˆæœ¬é«˜
- LangGraph æä¾›â€œæ˜¾å¼çŠ¶æ€ä¸çŠ¶æ€è½¬ç§»â€çš„å·¥ä½œæµæŠ½è±¡ï¼Œæ›´ç›´è§‚å¯æ§ã€æ˜“ç›‘æ§ä¸æ¢å¤

### 9.2 æ ¸å¿ƒæ¦‚å¿µ
- **Stateï¼ˆçŠ¶æ€ï¼‰**ï¼šæµç¨‹è¿è¡Œæ—¶çš„æ•°æ®è½½ä½“ï¼Œé€šå¸¸æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼ŒåŒ…å«ä¸Šä¸‹æ–‡ã€æ­¥éª¤ç»“æœã€é”™è¯¯ç­‰
- **Channelsï¼ˆé€šé“ï¼‰**ï¼šå¯¹çŠ¶æ€å­—æ®µçš„å£°æ˜ï¼Œæ§åˆ¶è¯»å†™ä¸åˆå¹¶ç­–ç•¥ï¼ˆä¾‹å¦‚ append åˆå¹¶ï¼‰
- **Nodeï¼ˆèŠ‚ç‚¹ï¼‰**ï¼šåŸå­æ­¥éª¤/ä»»åŠ¡ï¼Œè¾“å…¥ stateï¼Œè¾“å‡º state çš„å¢é‡
- **Edgeï¼ˆè¾¹ï¼‰**ï¼šèŠ‚ç‚¹é—´çš„æœ‰å‘è¿æ¥ï¼Œå¯æ¡ä»¶è·³è½¬
- **Compileï¼ˆç¼–è¯‘ï¼‰**ï¼šæ„å»ºå®Œæˆåç¼–è¯‘ä¸ºå¯æ‰§è¡Œçš„å›¾ï¼ˆgraph appï¼‰

### 9.3 æœ€å°ç¤ºä¾‹
```typescript
// æ–‡ä»¶ï¼šsrc/ch09/minimal.ts
import { StateGraph } from "@langchain/langgraph";

// å£°æ˜çŠ¶æ€ç»“æ„
type FlowState = {
  input: string;
  result?: string;
  error?: string;
};

export async function buildMinimalGraph() {
  const graph = new StateGraph<FlowState>({
    channels: {
      input: { value: "" },
      result: { value: "" },
      error: { value: "" },
    },
  });

  graph.addNode("echo", async (s) => ({ result: `ECHO: ${s.input}` }));
  graph.addEdge("start", "echo");
  graph.addEdge("echo", "end");

  return graph.compile();
}
```

---

## ğŸ§± State ä¸ Channels çš„è®¾è®¡

### 9.4 è®¾è®¡è¦ç‚¹
- å°†â€œå¯å›æ”¾ã€å¯è§‚å¯Ÿâ€çš„æ•°æ®éƒ½æ”¾å…¥ stateï¼šè¾“å…¥ã€æ­¥éª¤ç»“æœã€æ£€ç´¢å‘½ä¸­ã€LLM è¾“å‡ºã€é”™è¯¯
- é€šé“å£°æ˜å†³å®šå­—æ®µåˆå¹¶ç­–ç•¥ï¼šä¾‹å¦‚ `messages` é€šé“ç”¨ appendï¼›`result` ç”¨è¦†ç›–
- æ³¨æ„éšç§å­—æ®µï¼šæ•æ„Ÿæ•°æ®åº”è„±æ•æˆ–åªå­˜å¼•ç”¨

### 9.5 ç¤ºä¾‹ï¼šRAG æµç¨‹ State
```typescript
// æ–‡ä»¶ï¼šsrc/ch09/state.ts
export type RagState = {
  question: string;
  retriever: "topk" | "mmr" | "hybrid" | "time" | "user";
  hits: Array<{ id: string; text: string; meta: any; score?: number }>;
  fused: Array<{ id: string; text: string; meta: any }>; // å»å†—ä½™/é‡æ’å
  answer?: { answer: string; citations: any[]; confidence: number };
  feedback?: { rating?: number; comment?: string };
  logs: string[]; // å›æ”¾è½¨è¿¹
  error?: string;
};
```

---

## ğŸ”— èŠ‚ç‚¹ï¼ˆNodesï¼‰ç¼–æ’ï¼šæ£€ç´¢ â†’ èåˆ â†’ ç”Ÿæˆ â†’ æ ¡éªŒ â†’ åé¦ˆ

### 9.6 èŠ‚ç‚¹å®ç°
```typescript
// æ–‡ä»¶ï¼šsrc/ch09/nodes.ts
import { RunnableLambda, RunnableSequence } from "@langchain/core/runnables";
import { ChatOpenAI } from "@langchain/openai";
import { JsonOutputParser } from "@langchain/core/output_parsers";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { RagState } from "./state";
import { hybridRetriever, timeAwareRetriever, userAwareRetriever, topKRetriever } from "./retrievers";

export const retrieveNode = async (s: RagState): Promise<Partial<RagState>> => {
  let retr = await topKRetriever("news");
  if (s.retriever === "hybrid") retr = await hybridRetriever("news");
  if (s.retriever === "time") retr = await timeAwareRetriever("news");
  if (s.retriever === "user") retr = await userAwareRetriever("news", { id: "u1", dept: "it" });
  const hits = await retr(s.question);
  return { hits, logs: [`æ£€ç´¢åˆ° ${hits.length} æ¡`] };
};

export const fuseNode = async (s: RagState): Promise<Partial<RagState>> => {
  // ç®€åŒ–çš„å»å†—ä½™åˆå¹¶
  const seen = new Set();
  const fused = [] as RagState["fused"];
  for (const h of s.hits || []) {
    const key = `${h.meta?.source}#${h.meta?.chunkIndex}`;
    if (seen.has(key)) continue; seen.add(key);
    fused.push({ id: key, text: h.text, meta: h.meta });
  }
  return { fused, logs: ["å·²èåˆå»é‡"] };
};

const prompt = ChatPromptTemplate.fromMessages([
  ["system", `ä½ æ˜¯ä¸¥è°¨çš„ä¼ä¸šçŸ¥è¯†åŠ©æ‰‹ï¼Œä»…ä¾æ®å€™é€‰ç‰‡æ®µå›ç­”ï¼Œå¼•ç”¨å¿…é¡»ç»™å‡ºæ¥æºã€‚è¾“å‡º JSONï¼š
{"answer": string, "citations": [{"source": string, "chunkId": string}], "confidence": number}`],
  ["human", `é—®é¢˜ï¼š{q}\nå€™é€‰ï¼š\n{chunks}\nè¾“å‡º JSONï¼š`],
]);

export const answerNode = async (s: RagState): Promise<Partial<RagState>> => {
  const llm = new ChatOpenAI({ temperature: 0 });
  const seq = RunnableSequence.from([
    new RunnableLambda((i: any) => ({
      q: i.question,
      chunks: (i.fused || []).map((c: any, i: number) => `#${i} [${c.meta?.source}] ${String(c.text).slice(0, 300)}`).join("\n"),
    })),
    prompt,
    llm,
    new JsonOutputParser(),
  ]);
  const ans = await seq.invoke(s);
  return { answer: ans, logs: ["å·²ç”Ÿæˆå›ç­”"] };
};

export const guardNode = async (s: RagState): Promise<Partial<RagState>> => {
  if (!s.answer) return { error: "NO_ANSWER", logs: ["å›ç­”ä¸ºç©º"] };
  const ok = Array.isArray(s.answer.citations) && s.answer.citations.length > 0;
  if (!ok) return { error: "INVALID_CITATIONS", logs: ["ç¼ºå°‘å¼•ç”¨"] };
  return { logs: ["å¼•ç”¨æ ¡éªŒé€šè¿‡"] };
};

export const feedbackNode = async (s: RagState): Promise<Partial<RagState>> => {
  // è¿™é‡Œå¯ä»¥æŠŠåé¦ˆå†™å…¥æ•°æ®åº“/æ—¥å¿—ç³»ç»Ÿ
  return { logs: ["å·²è®°å½•åé¦ˆ"] };
};
```

> è¯´æ˜ï¼š`retrievers.ts` åœ¨æœ¬ç« ç¨åæä¾›ï¼Œç¤ºä¾‹å¯¹æ¥ç¬¬7ç« çš„æ£€ç´¢å®ç°ã€‚

---

## ğŸŒ³ æ¡ä»¶åˆ†æ”¯ã€å¾ªç¯ä¸å¹¶è¡Œ

### 9.7 æ¡ä»¶åˆ†æ”¯ï¼ˆConditional Edgesï¼‰
```typescript
// æ–‡ä»¶ï¼šsrc/ch09/graph-basic.ts
import { StateGraph } from "@langchain/langgraph";
import { RagState } from "./state";
import { retrieveNode, fuseNode, answerNode, guardNode, feedbackNode } from "./nodes";

export async function buildRagGraph() {
  const graph = new StateGraph<RagState>({
    channels: {
      question: { value: "" },
      retriever: { value: "topk" },
      hits: { value: [] },
      fused: { value: [] },
      answer: { value: { answer: "", citations: [], confidence: 0 } },
      feedback: { value: {} },
      logs: { value: [], merge: (prev, next) => [...prev, ...next] },
      error: { value: "" },
    },
  });

  graph.addNode("retrieve", retrieveNode);
  graph.addNode("fuse", fuseNode);
  graph.addNode("answer", answerNode);
  graph.addNode("guard", guardNode);
  graph.addNode("feedback", feedbackNode);

  graph.addEdge("start", "retrieve");
  graph.addEdge("retrieve", "fuse");
  graph.addEdge("fuse", "answer");

  // æ¡ä»¶ï¼šè‹¥ guard æ— é”™è¯¯ â†’ endï¼›å¦åˆ™å›åˆ° retrieve é‡è¯•ï¼ˆæœ€å¤š 1 æ¬¡ï¼Œæ¼”ç¤ºï¼‰
  graph.addConditionalEdges("answer", (s) => (s.error ? "retry" : "guard"), {
    guard: "guard",
    retry: "retrieve",
  });

  graph.addConditionalEdges("guard", (s) => (s.error ? "end" : "feedback"), {
    feedback: "feedback",
  });

  graph.addEdge("feedback", "end");

  return graph.compile();
}
```

### 9.8 å¾ªç¯ï¼ˆLoopï¼‰ä¸é‡è¯•ç­–ç•¥
- å¯ä»¥é€šè¿‡åœ¨ `addConditionalEdges` ä¸­è®©æŸèŠ‚ç‚¹æŒ‡å‘è‡ªèº«æˆ–ä¸Šæ¸¸èŠ‚ç‚¹å®ç°å¾ªç¯
- åº”é…åˆè®¡æ•°å™¨ / è¶…æ—¶æ§åˆ¶ï¼Œé¿å…æ— é™å¾ªç¯

```typescript
// æ–‡ä»¶ï¼šsrc/ch09/retry.ts
import { StateGraph } from "@langchain/langgraph";
import { RagState } from "./state";

export async function buildRetryGraph() {
  const graph = new StateGraph<RagState>({ channels: { question: { value: "" }, logs: { value: [], merge: (a,b)=>[...a,...b] }, error: { value: "" } } });
  graph.addNode("do", async (s) => {
    if (!s.error) {
      return { error: "TRANSIENT", logs: ["æ¨¡æ‹Ÿä¸€æ¬¡å¤±è´¥"] };
    }
    return { logs: ["ç¬¬äºŒæ¬¡æˆåŠŸ"] };
  });
  graph.addConditionalEdges("do", (s) => (s.error ? "retry" : "end"), { retry: "do" });
  graph.addEdge("start", "do");
  return graph.compile();
}
```

### 9.9 å¹¶è¡Œï¼ˆParallelï¼‰ä¸åˆå¹¶
- 0.3 ç‰ˆæœ¬æ¨èå°†â€œå¹¶è¡Œä»»åŠ¡â€æ‹†ä¸ºå¤šä¸ªèŠ‚ç‚¹å¹¶åœ¨çŠ¶æ€ä¸Šåˆå¹¶ç»“æœ
- åœ¨ Next.js å±‚å¯ç”¨ `Promise.all` ç­‰å¹¶å‘å·¥å…·ï¼›åœ¨å›¾ä¸­ä½“ç°ä¸ºå¤šä¸ªæ”¯è·¯åæ±‡åˆ

```typescript
// æ–‡ä»¶ï¼šsrc/ch09/parallel.ts
import { StateGraph } from "@langchain/langgraph";

type PState = { a?: number; b?: number; sum?: number };

export async function buildParallelGraph() {
  const g = new StateGraph<PState>({ channels: { a: { value: 0 }, b: { value: 0 }, sum: { value: 0 } } });
  g.addNode("A", async () => ({ a: 1 }));
  g.addNode("B", async () => ({ b: 2 }));
  g.addNode("SUM", async (s) => ({ sum: (s.a || 0) + (s.b || 0) }));
  g.addEdge("start", "A");
  g.addEdge("start", "B");
  g.addEdge("A", "SUM");
  g.addEdge("B", "SUM");
  g.addEdge("SUM", "end");
  return g.compile();
}
```

---

## â¸ï¸ ä¸­æ–­ã€äººå·¥å®¡æ‰¹ä¸æ¢å¤

### 9.10 ä¸­æ–­ç‚¹ï¼ˆInterruptï¼‰
- å…¸å‹åœºæ™¯ï¼šéœ€è¦äº§å“ç»ç†/æ³•åŠ¡å®¡æ ¸ã€æ”¯ä»˜ç¡®è®¤ã€äººå·¥é€‰æ‹©æ–¹æ¡ˆ
- æ€è·¯ï¼šåœ¨èŠ‚ç‚¹ä¸­æ£€æµ‹æ¡ä»¶åï¼Œè¿”å› `error="NEED_APPROVAL"` å¹¶å†™å…¥ `approvalToken`
- å‰ç«¯æ‹¿åˆ° tokenï¼Œå±•ç¤ºå®¡æ‰¹ UIï¼›å®¡æ‰¹åé€šè¿‡ `/api/graph/resume` ç»§ç»­

```typescript
// æ–‡ä»¶ï¼šsrc/ch09/approval.ts
import { StateGraph } from "@langchain/langgraph";

type ApprovalState = { input: string; approved?: boolean; token?: string; result?: string; error?: string };

export async function buildApprovalGraph() {
  const g = new StateGraph<ApprovalState>({ channels: { input: { value: "" }, approved: { value: false }, token: { value: "" }, result: { value: "" }, error: { value: "" } } });
  g.addNode("check", async (s) => {
    if (!s.approved) {
      const token = Math.random().toString(36).slice(2, 10);
      return { error: "NEED_APPROVAL", token };
    }
    return { result: `å·²é€šè¿‡ï¼š${s.input}` };
  });
  g.addConditionalEdges("check", (s) => (s.error === "NEED_APPROVAL" ? "pause" : "end"), { pause: "end" });
  g.addEdge("start", "check");
  return g.compile();
}
```

> è¯´æ˜ï¼šåœ¨ç”Ÿäº§ä¸­åº”å°† state å­˜å‚¨åˆ°æ•°æ®åº“ï¼Œ`token` ä¸ä¼šè¯å…³è”ï¼Œå¾…å®¡æ‰¹å®Œæˆåæ¢å¤ã€‚

---

## ğŸ§© ä¸ Runnableã€Memoryã€Callback çš„æ•´åˆ

### 9.11 å°† Runnable é“¾åµŒå…¥èŠ‚ç‚¹
- åœ¨ `addNode` çš„å¤„ç†å‡½æ•°ä¸­ä½¿ç”¨ `RunnableSequence` / `pipe` æ‰§è¡Œ LLM ä¸è§£æ
- å°†ä¸­é—´æ—¥å¿—å†™å…¥ `logs` é€šé“ï¼Œé…åˆ Callback ä¸ŠæŠ¥åˆ°è§‚æµ‹å¹³å°ï¼ˆå¦‚ LangSmithï¼‰

### 9.12 Memoryï¼šè·¨èŠ‚ç‚¹å…±äº«ä¸Šä¸‹æ–‡ä¸å¯¹è¯
- å°† `messages` æ”¾å…¥ stateï¼Œè®¾ç½®é€šé“åˆå¹¶ç­–ç•¥ä¸º append
- èŠ‚ç‚¹æŒ‰éœ€è¯»å–æœ€è¿‘çª—å£æˆ–æ‘˜è¦ï¼ˆå‚è§ç¬¬3ç« ï¼‰

### 9.13 Callbackï¼šå¯è§‚æµ‹æ€§
- åœ¨æ¯ä¸ªèŠ‚ç‚¹å…¥å£/å‡ºå£ä¸ŠæŠ¥â€œå¼€å§‹/ç»“æŸ/è€—æ—¶/é”™è¯¯â€
- ç»Ÿä¸€ RunId ä¸²è”å…¨é“¾è·¯ï¼›Next.js API ä¸­æ³¨å…¥ requestId

---

## ğŸŒ Next.js é›†æˆï¼šå›¾å¼•æ“ API ä¸å‰ç«¯çŠ¶æ€å›¾æŸ¥çœ‹å™¨

### 9.14 è¿è¡Œå›¾çš„æœåŠ¡ç«¯ API
```typescript
// æ–‡ä»¶ï¼šsrc/app/api/graph/run/route.ts
import { NextRequest } from "next/server";
import { buildRagGraph } from "@/src/ch09/graph-basic";

export const runtime = "edge";

export async function POST(req: NextRequest) {
  const body = await req.json();
  const app = await buildRagGraph();
  try {
    const out = await app.invoke({
      question: body.question || "ä»€ä¹ˆæ˜¯ LangGraphï¼Ÿ",
      retriever: body.retriever || "hybrid",
      hits: [], fused: [], logs: [],
    });
    return Response.json({ ok: true, data: out });
  } catch (e: any) {
    return Response.json({ ok: false, message: e.message }, { status: 500 });
  }
}
```

### 9.15 å¯è§†åŒ–æŸ¥çœ‹å™¨ï¼ˆå‰ç«¯ï¼‰
```tsx
// æ–‡ä»¶ï¼šsrc/app/graph/page.tsx
"use client";
import { useState } from "react";

export default function GraphPage() {
  const [q, setQ] = useState("");
  const [data, setData] = useState<any>(null);
  const [loading, setLoading] = useState(false);

  const run = async () => {
    setLoading(true);
    const res = await fetch("/api/graph/run", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ question: q || "å…¬å¸æŠ¥é”€æ”¿ç­–ï¼Ÿ", retriever: "hybrid" }),
    });
    const json = await res.json();
    setData(json.data);
    setLoading(false);
  };

  return (
    <main className="max-w-3xl mx-auto p-4 space-y-4">
      <h1 className="text-2xl font-bold">LangGraph çŠ¶æ€å›¾æŸ¥çœ‹å™¨</h1>
      <div className="flex gap-2">
        <input value={q} onChange={e=>setQ(e.target.value)} placeholder="è¾“å…¥é—®é¢˜" className="flex-1 border rounded px-3 py-2" />
        <button onClick={run} className="px-4 py-2 bg-blue-600 text-white rounded" disabled={loading}>{loading?"è¿è¡Œä¸­...":"è¿è¡Œ"}</button>
      </div>
      {data && (
        <section className="space-y-2">
          <h2 className="font-semibold">æ‰§è¡Œç»“æœ</h2>
          <pre className="whitespace-pre-wrap break-words text-sm bg-gray-50 p-3 rounded">{JSON.stringify(data, null, 2)}</pre>
        </section>
      )}
    </main>
  );
}
```

---

## ğŸš€ å®æˆ˜ï¼šçŸ¥è¯†å…¥åº“ + RAG é—®ç­” + åé¦ˆé—­ç¯

### 9.16 åœºæ™¯è¯´æ˜
- ç”¨æˆ·æé—® â†’ æ£€ç´¢ä¸ç”Ÿæˆ â†’ ç”¨æˆ·åé¦ˆï¼ˆæ»¡æ„/ä¸æ»¡æ„ï¼‰â†’ å†™å›åé¦ˆä¸æ”¹è¿›æ•°æ®
- å…¥åº“æµç¨‹å¯ç‹¬ç«‹ä¸ºå¦ä¸€å¼ å›¾ï¼šæ–‡ä»¶ä¸Šä¼  â†’ æ¸…æ´— â†’ åˆ‡åˆ† â†’ å‘é‡åŒ– â†’ ç´¢å¼•æ„å»º â†’ é€šçŸ¥å®Œæˆ

### 9.17 RAG å›¾ + åé¦ˆèŠ‚ç‚¹
```typescript
// æ–‡ä»¶ï¼šsrc/ch09/app.ts
import { StateGraph } from "@langchain/langgraph";
import { RagState } from "./state";
import { retrieveNode, fuseNode, answerNode, guardNode, feedbackNode } from "./nodes";

export async function buildRagWithFeedback() {
  const g = new StateGraph<RagState>({
    channels: {
      question: { value: "" },
      retriever: { value: "hybrid" },
      hits: { value: [] }, fused: { value: [] },
      answer: { value: { answer: "", citations: [], confidence: 0 } },
      feedback: { value: {} },
      logs: { value: [], merge: (a,b)=>[...a,...b] },
      error: { value: "" },
    }
  });
  g.addNode("retrieve", retrieveNode);
  g.addNode("fuse", fuseNode);
  g.addNode("answer", answerNode);
  g.addNode("guard", guardNode);
  g.addNode("feedback", feedbackNode);

  g.addEdge("start", "retrieve");
  g.addEdge("retrieve", "fuse");
  g.addEdge("fuse", "answer");
  g.addEdge("answer", "guard");
  g.addConditionalEdges("guard", s => (s.error ? "end" : "feedback"), { feedback: "feedback" });
  g.addEdge("feedback", "end");

  return g.compile();
}
```

### 9.18 å…¥åº“ï¼ˆIngestï¼‰å›¾
```typescript
// æ–‡ä»¶ï¼šsrc/ch09/ingest.ts
import { StateGraph } from "@langchain/langgraph";

type IngestState = { dir: string; name: string; chunks?: number; ok?: boolean; error?: string; logs: string[] };

export async function buildIngestGraph() {
  const g = new StateGraph<IngestState>({ channels: { dir: { value: "./docs" }, name: { value: "news" }, chunks: { value: 0 }, ok: { value: false }, error: { value: "" }, logs: { value: [], merge: (a,b)=>[...a,...b] } } });
  g.addNode("load", async (s) => ({ logs: ["åŠ è½½æ–‡æ¡£"], chunks: 300 }));
  g.addNode("embed", async (s) => ({ logs: ["å‘é‡åŒ–å¹¶å…¥åº“"], ok: true }));
  g.addEdge("start", "load");
  g.addEdge("load", "embed");
  g.addEdge("embed", "end");
  return g.compile();
}
```

### 9.19 APIï¼šä¸€é”®è¿è¡Œä¸¤å¼ å›¾
```typescript
// æ–‡ä»¶ï¼šsrc/app/api/pipeline/route.ts
import { NextRequest } from "next/server";
import { buildIngestGraph } from "@/src/ch09/ingest";
import { buildRagWithFeedback } from "@/src/ch09/app";

export const runtime = "edge";

export async function POST(req: NextRequest) {
  const { dir, name, question } = await req.json();
  try {
    const ingest = await buildIngestGraph();
    const r1 = await ingest.invoke({ dir: dir || "./docs", name: name || "news", logs: [] });

    const app = await buildRagWithFeedback();
    const r2 = await app.invoke({ question: question || "ä»Šå¤©æœ‰å“ªäº›æ–°å…¬å‘Šï¼Ÿ", retriever: "hybrid", hits: [], fused: [], logs: [] });

    return Response.json({ ok: true, ingest: r1, rag: r2 });
  } catch (e: any) {
    return Response.json({ ok: false, message: e.message }, { status: 500 });
  }
}
```

---

## âš™ï¸ å·¥ç¨‹åŒ–ï¼šæŒä¹…åŒ–ã€æ¢å¤ã€ç›‘æ§ä¸è¯„ä¼°

### 9.20 çŠ¶æ€æŒä¹…åŒ–ä¸æ¢å¤
- å°†æ¯ä¸€æ­¥çš„ state å†™å…¥æ•°æ®åº“ï¼ˆæ¨èï¼šPostgreSQL/SQLite + JSONBï¼›æˆ– KV å­˜å‚¨ï¼‰
- RunId è´¯ç©¿æ•´ä¸ªæµç¨‹ï¼›æ”¯æŒ resumeï¼ˆå¸¦ä¸Šæœ€åä¸€ä¸ªæˆåŠŸèŠ‚ç‚¹å’Œ stateï¼‰

### 9.21 å¯è§‚æµ‹æ€§
- å…³é”®æŒ‡æ ‡ï¼šèŠ‚ç‚¹è€—æ—¶ã€é‡è¯•æ¬¡æ•°ã€å¤±è´¥ç‡ã€é˜Ÿåˆ—é•¿åº¦ã€ç§¯å‹æ—¶é•¿
- ç»“åˆå›è°ƒä¸æ—¥å¿—ä¸ŠæŠ¥ï¼ˆå‚è€ƒç¬¬4ç« ï¼‰ï¼Œå¹¶æ¥å…¥ LangSmith æˆ–è‡ªå»ºç›‘æ§

### 9.22 è¯„ä¼°ä¸å›æ”¾
- ä¿å­˜è¾“å…¥ã€å‘½ä¸­ç‰‡æ®µã€å›ç­”ã€å¼•ç”¨ã€åé¦ˆï¼Œæ„å»ºç¦»çº¿è¯„ä¼°é›†
- è¯„ä¼°æŒ‡æ ‡ï¼šRecall@Kã€MRRã€Citation Accuracyã€æ»¡æ„åº¦ã€æˆæœ¬ã€å»¶è¿Ÿ

### 9.23 å®‰å…¨ä¸æƒé™
- èŠ‚ç‚¹æŒ‰åŠŸèƒ½åŸŸåˆ’åˆ†æƒé™ï¼ˆå¦‚æ•æ„Ÿæ•°æ®ä»…åœ¨å—é™èŠ‚ç‚¹å¯è§ï¼‰
- äººå·¥å®¡æ‰¹èŠ‚ç‚¹è¦æœ‰å®¡è®¡æ—¥å¿—ï¼›æ•°æ®è„±æ•ä¸æ°´å°

---

## ğŸ“š å»¶ä¼¸é“¾æ¥
- LangGraph æ–‡æ¡£ï¼š`https://langchain-ai.github.io/langgraph/`
- LangChain Runnableï¼š`https://js.langchain.com/docs/expression_language/why`
- çŠ¶æ€æœº/å·¥ä½œæµç†è®ºå‚è€ƒï¼š`https://en.wikipedia.org/wiki/Workflow`ã€`https://en.wikipedia.org/wiki/Finite-state_machine`

---

## âœ… æœ¬ç« å°ç»“
- ç†è§£äº† LangGraph çš„çŠ¶æ€/èŠ‚ç‚¹/è¾¹/ç¼–è¯‘æ¨¡å‹
- æŒæ¡äº†æ¡ä»¶åˆ†æ”¯ã€å¾ªç¯é‡è¯•ã€å¹¶è¡Œä¸ä¸­æ–­çš„ç¼–æ’æ–¹å¼
- å°† Runnableã€Memoryã€Callback ä¸ LangGraph è”åŠ¨ï¼Œæ‰“é€ å¯è§‚æµ‹ä¸å¯æ¢å¤çš„é•¿æµç¨‹
- åœ¨ Next.js ä¸­æä¾›äº†å›¾å¼•æ“ API ä¸æŸ¥çœ‹å™¨ï¼Œå®Œæˆâ€œå…¥åº“ + RAG + åé¦ˆâ€çš„ç«¯åˆ°ç«¯å®æˆ˜

## ğŸ¯ ä¸‹ç« é¢„å‘Š
ä¸‹ä¸€ç« ã€ŠRAG ä¸ Agent çš„ååŒç¼–æ’å®è·µã€‹ä¸­ï¼Œæˆ‘ä»¬å°†ï¼š
- ç”¨ LangGraph ç¼–æ’ RAG ä¸ Agent çš„åä½œ
- æ„å»ºå·¥å…·å‹ Agent è°ƒç”¨æ£€ç´¢ã€è°ƒç”¨ API çš„å®Œæ•´é—­ç¯
- é€šè¿‡äº‹ä»¶æ€»çº¿ä¸å¯è§†åŒ–ï¼Œå‘ˆç°ç«¯åˆ°ç«¯æ‰§è¡Œè½¨è¿¹

> æœ€åæ„Ÿè°¢é˜…è¯»ï¼æ¬¢è¿å…³æ³¨æˆ‘ï¼Œå¾®ä¿¡å…¬ä¼—å·ï¼š`ã€Šé²«å°é±¼ä¸æ­£ç»ã€‹`ã€‚æ¬¢è¿ç‚¹èµã€æ”¶è—ã€å…³æ³¨ï¼Œä¸€é”®ä¸‰è¿ï¼ï¼ï¼
